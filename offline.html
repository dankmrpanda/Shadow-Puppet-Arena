<!DOCTYPE html>
<html>

<head>
    <meta charset=utf-8>
    <meta name=viewport content="width=device-width,initial-scale=1,user-scalable=no">
    <title>Shadow Puppet Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0
        }

        body {
            background: #0d0d12;
            color: #e0e0e0;
            font: 14px sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center
        }

        button {
            font-family: inherit;
            cursor: pointer;
            user-select: none
        }

        #menu {
            text-align: center;
            padding: 15px
        }

        #menu button {
            font-size: 16px;
            padding: 12px 24px;
            margin: 8px;
            border-radius: 8px;
            border: none;
            background: linear-gradient(135deg, #6a4c93, #4a2d8e);
            color: #fff;
            box-shadow: 0 4px 15px rgba(106, 76, 147, 0.4)
        }

        #menu button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(106, 76, 147, 0.6)
        }

        #c {
            background: #1a1a24;
            border-radius: 8px;
            cursor: crosshair;
            max-width: 95vw;
            max-height: 50vh;
            border: 2px solid #333;
            display: none
        }

        #ui {
            display: none;
            padding: 10px;
            text-align: center
        }

        #ui button {
            font-size: 14px;
            padding: 8px 16px;
            margin: 4px;
            border-radius: 6px;
            border: 1px solid #444;
            background: #4a2d8e;
            color: #fff
        }

        #arena {
            display: none;
            width: 100%;
            flex: 1;
            flex-direction: column;
            align-items: center;
            padding-top: 10px
        }

        #ac {
            background: #1a1a24;
            border-radius: 8px;
            max-width: 100%;
            max-height: 60vh
        }

        .hint {
            font-size: 11px;
            color: #888;
            margin: 4px
        }

        #clear {
            background: #555
        }

        #log {
            font-size: 11px;
            color: #aaa;
            max-height: 60px;
            overflow-y: auto;
            width: 90%;
            text-align: left;
            padding: 6px;
            background: #151520;
            border-radius: 6px;
            margin-top: 4px
        }

        #blastBtn {
            background: #c0392b;
            color: #fff;
            font-size: 14px;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            margin: 4px
        }

        #blastBtn:disabled {
            background: #555
        }

        #abilityBtn {
            background: #9b59b6;
            color: #fff;
            font-size: 14px;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            margin: 4px
        }

        #abilityBtn:disabled {
            background: #555
        }
    </style>
</head>

<body>
    <div id=menu>
        <h1
            style="background:linear-gradient(135deg,#9b59b6,#3498db);-webkit-background-clip:text;-webkit-text-fill-color:transparent;font-size:28px;margin-bottom:10px">
            Shadow Puppet Arena</h1>
        <p style="margin:8px;color:#aaa">Draw a shape. Battle AI opponents!</p>
        <button id=start1>1 vs 1</button>
        <button id=start3>1 vs 3</button>
        <button id=start5>1 vs 5</button>
        <p class=hint style="margin-top:20px">Offline Version</p>
    </div>
    <div id=ui>
        <p id=drawStatus style="margin:4px;color:#888">Draw your monster</p>
        <canvas id=c width=300 height=300></canvas>
        <p class=hint>Draw in ONE stroke. Shape will auto-close.</p>
        <button id=clear>Clear</button><button id=loadScotty style="background:#c0392b">Load Scotty</button><button id=done>Fight!</button>
    </div>
    <div id=arena>
        <canvas id=ac width=900 height=640></canvas>
        <div style="margin:4px"><button id=blastBtn>Blast</button><button id=abilityBtn>Ability</button></div>
        <div id=log></div>
        <button id=restart
            style="background:#27ae60;color:#fff;padding:8px 16px;border:none;border-radius:6px;margin-top:8px;display:none">Play
            Again</button>
    </div>
    <script>
        (function () {
            var W = 900, H = 640, MAX_HP = 150, BASE_SIZE = 30, MIN_SPEED = 0.6, MAX_VEL = 4;
            var path = [], myColor = '#6a4c93', monsters = {}, packs = [], powerups = [], hazards = [], particles = [], blastFx = [], floatTexts = [], activeBlasts = [];
            var bounds = [0, 0, W, H], tickCount = 0, suddenDeath = false, numBots = 3, gameLoop = null;
            var POWERUP_TYPES = ['speed', 'shield', 'damage', 'ghost'];
            var POWERUP_DURATION = { speed: 300, shield: 180, damage: 300, ghost: 240 };
            var aiColors = ['#e74c3c', '#f39c12', '#3498db', '#2ecc71', '#e91e63'];
            var logEl = document.getElementById('log');

            function rand(a, b) { return Math.random() * (b - a) + a }
            function addLog(t) { logEl.innerHTML += '<div>' + t + '</div>'; logEl.scrollTop = logEl.scrollHeight }
            function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)) }
            function verts(m) {
                var s = m.size / 40, cx = 0, cy = 0;
                for (var i = 0; i < m.path.length; i++) { cx += m.path[i][0] * 12; cy += m.path[i][1] * 12 }
                cx /= m.path.length; cy /= m.path.length;
                var o = [];
                for (var i = 0; i < m.path.length; i++) o.push([m.x + (m.path[i][0] * 12 - cx) * s, m.y + (m.path[i][1] * 12 - cy) * s]);
                return o
            }
            function ptInPoly(px, py, v) {
                var n = 0;
                for (var i = 0, j = v.length - 1; i < v.length; j = i++) {
                    var yi = v[i][1], yj = v[j][1], xi = v[i][0], xj = v[j][0];
                    if (((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi + 1e-10) + xi)) n++
                }
                return n % 2 === 1
            }
            function segsIntersect(a1, a2, b1, b2) {
                var d = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);
                if (Math.abs(d) < 1e-10) return false;
                var ua = ((b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0])) / d;
                var ub = ((a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0])) / d;
                return ua > 0 && ua < 1 && ub > 0 && ub < 1
            }
            function polyOverlap(a, b) {
                var va = verts(a), vb = verts(b);
                for (var i = 0; i < va.length; i++)if (ptInPoly(va[i][0], va[i][1], vb)) return true;
                for (var i = 0; i < vb.length; i++)if (ptInPoly(vb[i][0], vb[i][1], va)) return true;
                for (var i = 0; i < va.length; i++) {
                    var a1 = va[i], a2 = va[(i + 1) % va.length];
                    for (var j = 0; j < vb.length; j++) if (segsIntersect(a1, a2, vb[j], vb[(j + 1) % vb.length])) return true
                }
                return false
            }
            function clampBounds(m) {
                var v = verts(m), mnX = 1e9, mxX = -1e9, mnY = 1e9, mxY = -1e9;
                for (var i = 0; i < v.length; i++) { mnX = Math.min(mnX, v[i][0]); mxX = Math.max(mxX, v[i][0]); mnY = Math.min(mnY, v[i][1]); mxY = Math.max(mxY, v[i][1]) }
                if (mnX < bounds[0]) { m.x += bounds[0] - mnX; m.vx = Math.abs(m.vx) * 0.9 }
                if (mxX > bounds[2]) { m.x -= mxX - bounds[2]; m.vx = -Math.abs(m.vx) * 0.9 }
                if (mnY < bounds[1]) { m.y += bounds[1] - mnY; m.vy = Math.abs(m.vy) * 0.9 }
                if (mxY > bounds[3]) { m.y -= mxY - bounds[3]; m.vy = -Math.abs(m.vy) * 0.9 }
            }

            var lightningWarning = null, lightningStrike = null;
            function spawnPack() {
                var m = 30;
                packs.push({ x: rand(bounds[0] + m, bounds[2] - m), y: rand(bounds[1] + m, bounds[3] - m), hp: Math.floor(rand(20, 50)) })
            }
            function spawnPowerup() {
                var m = 40;
                powerups.push({ x: rand(bounds[0] + m, bounds[2] - m), y: rand(bounds[1] + m, bounds[3] - m), type: POWERUP_TYPES[Math.floor(Math.random() * 4)] })
            }
            function spawnHazard() {
                var type = Math.random() < 0.5 ? 'fire' : 'vortex';
                var x = rand(bounds[0] + 50, bounds[2] - 50), y = rand(bounds[1] + 50, bounds[3] - 50);
                hazards.push({ x: x, y: y, type: type, age: 0, duration: type === 'fire' ? 375 : 500 })
            }
            function detectAbility(s) {
                if (s.c <= 1 && s.s > 0.7) return 'absorb';
                if (s.l >= 3) return 'dash';
                if (s.c >= 4) return 'block';
                return 'none'
            }
            function makeStats(p) {
                var corners = 0, pts = [];
                for (var i = 0; i < p.length; i++) pts.push({ x: p[i][0] * 12, y: p[i][1] * 12 });
                if (pts.length > 25) { var np = []; for (var i = 0; i < 20; i++)np.push(pts[Math.floor(i * (pts.length - 1) / 19)]); pts = np }
                for (var i = 2; i < pts.length; i++) {
                    var a = Math.atan2(pts[i].y - pts[i - 1].y, pts[i].x - pts[i - 1].x), b = Math.atan2(pts[i - 1].y - pts[i - 2].y, pts[i - 1].x - pts[i - 2].x);
                    var diff = Math.abs(a - b); if (diff > Math.PI) diff = 2 * Math.PI - diff; if (diff > 1.0) corners++
                }
                var cx = 0, cy = 0; for (var i = 0; i < pts.length; i++) { cx += pts[i].x; cy += pts[i].y } cx /= pts.length; cy /= pts.length;
                var left = 0, right = 0; for (var i = 0; i < pts.length; i++) { var v = pts[i].y - cy; if (pts[i].x < cx) left += v * v; else right += v * v }
                var sym = Math.min(1, 1 - Math.abs(left - right) / (left + right + 1));
                var segs = []; for (var i = 1; i < pts.length; i++)segs.push(Math.hypot(pts[i].x - pts[i - 1].x, pts[i].y - pts[i - 1].y));
                var avg = segs.reduce(function (a, b) { return a + b }, 0) / segs.length; var legs = 0; for (var i = 0; i < segs.length; i++)if (segs[i] > avg * 1.8) legs++;

                var area = 0;
                return { c: corners, s: sym, l: legs, a: area }
            }

            function initMonster(id, p, color, name, isBot) {
                var s = (!isBot && isScotty) ? { c: 20, s: 1.0, l: 5, a: 999 } : makeStats(p);
                var hp = Math.min(MAX_HP, Math.max(80, 80 + s.s * 40));
                var ability = detectAbility(s);
                var m = {
                    id: id, x: rand(100, W - 100), y: rand(80, H - 80), vx: 0, vy: 0,
                    path: p, name: name, color: color, baseSize: BASE_SIZE, size: BASE_SIZE,
                    hp: hp, maxHp: hp, iframes: 0,
                    spikes: Math.min(s.c, 5), stability: Math.min(s.s * 3, 2),
                    baseSpeed: 1.0 + Math.min(s.l * 0.15, 0.5), speed: 0,
                    ability: ability, abilityCooldown: 0, effects: {},
                    trail: [], stats: s, isBot: isBot, aiTimer: 0, target: null
                };
                m.speed = Math.max(MIN_SPEED, m.baseSpeed);
                return m
            }

            function update() {
                var alive = []; for (var id in monsters) { if (monsters[id].hp > 0) alive.push(id) }
                if (alive.length <= 1) {
                    clearInterval(gameLoop);
                    document.getElementById('restart').style.display = 'inline-block';
                    if (monsters[0] && monsters[0].hp > 0) addLog('ðŸ† You win!'); else addLog('ðŸ’€ Game over!');
                    return
                }

                tickCount++;

                if (tickCount % 900 === 0 && (bounds[2] - bounds[0]) > 180) {
                    var ph = Math.floor(tickCount / 900), sx = Math.min(12, 4 + ph), sy = Math.min(10, 3 + Math.floor(ph * 0.7));
                    bounds[0] += sx; bounds[1] += sy; bounds[2] -= sx; bounds[3] -= sy;
                    addLog('Arena shrinks!');
                    for (var id in monsters) clampBounds(monsters[id]);
                }
                var ph = Math.floor(tickCount / 900), packRate = (alive.length <= 2 ? 450 : 1200) + ph * 100;
                if (tickCount % packRate === 0 && packs.length < 3) spawnPack();
                if (tickCount % 900 === 0 && powerups.length < 2) spawnPowerup();
                if (tickCount > 2700 && tickCount % (1200 - Math.min(ph * 100, 600)) === 0 && hazards.length < 3) spawnHazard();

                if (tickCount > 3600 && tickCount % 900 === 500) lightningWarning = { x: rand(bounds[0] + 50, bounds[2] - 50), y: rand(bounds[1] + 50, bounds[3] - 50), t: tickCount };
                if (lightningWarning && tickCount - lightningWarning.t === 60) {
                    lightningStrike = { x: lightningWarning.x, y: lightningWarning.y };
                    for (var id in monsters) {
                        var m = monsters[id]; if (Math.hypot(m.x - lightningStrike.x, m.y - lightningStrike.y) < 60 && !m.effects.shield) {
                            m.hp -= 25; floatTexts.push({ x: m.x, y: m.y - 30, text: '-25', color: '#ff0', age: 0 }); addLog(m.name + ' struck by lightning!')
                        }
                    }
                    lightningWarning = null
                }
                if (lightningStrike && tickCount % 10 === 0) lightningStrike = null;

                if ((bounds[2] - bounds[0]) <= 180 && !suddenDeath) { suddenDeath = true; addLog('âš ï¸ SUDDEN DEATH!') }
                if (suddenDeath && tickCount % 60 === 0) for (var id in monsters) if (!monsters[id].effects.shield) { monsters[id].hp -= 2; floatTexts.push({ x: monsters[id].x, y: monsters[id].y - 15, text: '-2', color: '#a00', age: 0 }) }

                for (var id in monsters) {
                    var m = monsters[id]; if (m.hp <= 0) continue;
                    if (m.isBot) {
                        if (m.aiTimer <= 0) {
                            m.aiTimer = rand(30, 90);
                            var bestD = 1e9, bestT = null;
                            for (var oid in monsters) { if (oid != id && monsters[oid].hp > 0) { var d = Math.hypot(monsters[oid].x - m.x, monsters[oid].y - m.y); if (d < bestD) { bestD = d; bestT = oid } } }
                            m.target = bestT;
                            if (m.ability !== 'none' && m.abilityCooldown <= 0) {
                                if (m.ability === 'dash' && bestD > 150) useAbility(id);
                                else if (m.ability === 'block' && bestD < 80) useAbility(id);
                            }
                            if (bestD < 100 && Math.random() < 0.3) blast(id);
                        }
                        m.aiTimer--;
                        if (m.target && monsters[m.target] && monsters[m.target].hp > 0) {
                            var t = monsters[m.target], dx = t.x - m.x, dy = t.y - m.y, d = Math.hypot(dx, dy);
                            if (d > 5) { m.vx += (dx / d) * m.speed * 0.1; m.vy += (dy / d) * m.speed * 0.1 }
                        } else {
                            var dx = (bounds[0] + bounds[2]) / 2 - m.x, dy = (bounds[1] + bounds[3]) / 2 - m.y;
                            m.vx += dx * 0.001; m.vy += dy * 0.001;
                        }
                    }

                    m.size = Math.max(8, m.baseSize * (m.hp / m.maxHp));
                    var spMult = 1 + (1 - m.hp / m.maxHp) * 2; if (m.effects.speed) spMult *= 2;
                    m.speed = Math.max(MIN_SPEED, m.baseSpeed * spMult);
                    var cv = Math.hypot(m.vx, m.vy);
                    if (cv < MIN_SPEED && cv > 0.01) { m.vx = m.vx / cv * MIN_SPEED; m.vy = m.vy / cv * MIN_SPEED }
                    else if (cv <= 0.01) { var a = Math.random() * 6.28; m.vx = Math.cos(a) * MIN_SPEED; m.vy = Math.sin(a) * MIN_SPEED }
                    m.x += m.vx * m.speed; m.y += m.vy * m.speed;
                    clampBounds(m);
                    var v = Math.hypot(m.vx, m.vy); if (v > MAX_VEL) { m.vx = m.vx / v * MAX_VEL; m.vy = m.vy / v * MAX_VEL }

                    for (var k in m.effects) { m.effects[k]--; if (m.effects[k] <= 0) delete m.effects[k] }
                    if (m.abilityCooldown > 0) m.abilityCooldown--;
                    if (m.iframes > 0) m.iframes--;
                    m.trail.push({ x: m.x, y: m.y }); if (m.trail.length > 8) m.trail.shift();

                    var mv = verts(m);
                    for (var i = packs.length - 1; i >= 0; i--) { if (ptInPoly(packs[i].x, packs[i].y, mv)) { m.hp = Math.min(m.maxHp, m.hp + packs[i].hp); floatTexts.push({ x: packs[i].x, y: packs[i].y, text: '+' + packs[i].hp, color: '#2f2', age: 0 }); packs.splice(i, 1) } }
                    for (var i = powerups.length - 1; i >= 0; i--) { if (ptInPoly(powerups[i].x, powerups[i].y, mv)) { m.effects[powerups[i].type] = POWERUP_DURATION[powerups[i].type]; floatTexts.push({ x: powerups[i].x, y: powerups[i].y, text: powerups[i].type.toUpperCase(), color: '#ff0', age: 0 }); powerups.splice(i, 1) } }
                }

                for (var i = activeBlasts.length - 1; i >= 0; i--) {
                    var bl = activeBlasts[i];
                    for (var id in monsters) {
                        var m = monsters[id], dx = m.x - bl.x, dy = m.y - bl.y, d = Math.hypot(dx, dy) || 1;
                        if (d < 337) { var f = Math.max(0.4, (337 - d) / 60) * bl.ticks / 3; m.vx += dx / d * f; m.vy += dy / d * f }
                    }
                    bl.ticks--; if (bl.ticks <= 0) activeBlasts.splice(i, 1);
                }

                for (var i = hazards.length - 1; i >= 0; i--) {
                    var h = hazards[i]; h.age++;
                    if (h.age > h.duration) { hazards.splice(i, 1); continue }
                    for (var id in monsters) {
                        var m = monsters[id], d = Math.hypot(m.x - h.x, m.y - h.y);
                        if (h.type === 'fire' && d < 50 && tickCount % 30 === 0 && !m.effects.shield) { m.hp -= 3; floatTexts.push({ x: m.x, y: m.y - 20, text: '-3', color: '#f00', age: 0 }) }
                        if (h.type === 'vortex' && d < 100 && d > 10) { var p = 0.15 * (1 - d / 100); m.vx += (h.x - m.x) / d * p; m.vy += (h.y - m.y) / d * p }
                    }
                }

                var ids = Object.keys(monsters);
                for (var i = 0; i < ids.length; i++) {
                    for (var j = i + 1; j < ids.length; j++) {
                        var a = monsters[ids[i]], b = monsters[ids[j]];
                        if (a.hp <= 0 || b.hp <= 0 || a.effects.ghost || b.effects.ghost) continue;
                        if (!polyOverlap(a, b)) continue;
                        var dx = b.x - a.x, dy = b.y - a.y, d = Math.hypot(dx, dy) || 0.1, nx = dx / d, ny = dy / d;
                        var push = Math.max(0.15, (a.spikes - b.stability + b.spikes - a.stability) * 0.08);
                        a.vx -= nx * push; a.vy -= ny * push; b.vx += nx * push; b.vy += ny * push;
                        var sep = (a.size + b.size) * 0.1; a.x -= nx * sep; a.y -= ny * sep; b.x += nx * sep; b.y += ny * sep;
                        clampBounds(a); clampBounds(b);
                        if (a.iframes <= 0 && b.iframes <= 0) {
                            var va = Math.hypot(a.vx, a.vy), vb = Math.hypot(b.vx, b.vy);
                            var vma = 0.5 + (va / MAX_VEL) * 1.5, vmb = 0.5 + (vb / MAX_VEL) * 1.5;
                            var bda = (b.spikes - a.stability) * 3 * (b.effects.damage ? 2 : 1), bdb = (a.spikes - b.stability) * 3 * (a.effects.damage ? 2 : 1);
                            var da = a.effects.shield ? 0 : Math.ceil(Math.max(1, bda * vmb)), db = b.effects.shield ? 0 : Math.ceil(Math.max(1, bdb * vma));
                            a.hp -= da; b.hp -= db; a.iframes = 20; b.iframes = 20;
                            if (da > 0) floatTexts.push({ x: a.x, y: a.y - 20, text: '-' + da, color: vmb > 1.2 ? '#ff0' : '#f55', age: 0 });
                            if (db > 0) floatTexts.push({ x: b.x, y: b.y - 20, text: '-' + db, color: vma > 1.2 ? '#ff0' : '#f55', age: 0 });
                            if (a.ability === 'absorb' && db > 0) a.hp = Math.min(a.maxHp, a.hp + Math.floor(db / 2));
                            if (b.ability === 'absorb' && da > 0) b.hp = Math.min(b.maxHp, b.hp + Math.floor(da / 2));
                        }
                    }
                }

                for (var i = floatTexts.length - 1; i >= 0; i--) { floatTexts[i].age++; if (floatTexts[i].age > 40) floatTexts.splice(i, 1) }
                for (var i = particles.length - 1; i >= 0; i--) { var p = particles[i]; p.x += p.vx; p.y += p.vy; p.vx *= 0.95; p.vy *= 0.95; p.age++; if (p.age > 30) particles.splice(i, 1) }
                for (var i = blastFx.length - 1; i >= 0; i--) { blastFx[i].age++; if (blastFx[i].age > 20) blastFx.splice(i, 1) }

                render();
            }

            function blast(id) {
                var m = monsters[id]; if (!m || m.hp <= 0) return;
                blastFx.push({ x: m.x, y: m.y, age: 0 });
                activeBlasts.push({ x: m.x, y: m.y, ticks: 6 });
                addLog(m.name + ' used Blast!');
            }

            function useAbility(id) {
                var m = monsters[id]; if (!m || m.hp <= 0 || m.ability === 'none' || m.abilityCooldown > 0) return;
                m.abilityCooldown = 600;
                if (m.ability === 'dash') {
                    m.effects.speed = 180; var v = Math.hypot(m.vx, m.vy) || 1; m.vx = m.vx / v * 4; m.vy = m.vy / v * 4;
                    floatTexts.push({ x: m.x, y: m.y - 30, text: 'DASH!', color: '#0ff', age: 0 })
                } else if (m.ability === 'block') {
                    m.effects.shield = 180; floatTexts.push({ x: m.x, y: m.y - 30, text: 'BLOCK!', color: '#88f', age: 0 })
                }
            }

            function render() {
                var ctx = ac.getContext('2d'); ctx.fillStyle = '#180818'; ctx.fillRect(0, 0, 640, 480);
                ctx.fillStyle = '#0d0d12'; ctx.fillRect(bounds[0], bounds[1], bounds[2] - bounds[0], bounds[3] - bounds[1]);
                var isShrunk = bounds[0] > 0; ctx.strokeStyle = isShrunk ? '#ff0000' : '#555'; ctx.lineWidth = isShrunk ? 4 : 2; ctx.strokeRect(bounds[0], bounds[1], bounds[2] - bounds[0], bounds[3] - bounds[1]);

                for (var i = 0; i < packs.length; i++) { var p = packs[i]; ctx.fillStyle = '#2ecc71'; ctx.beginPath(); ctx.arc(p.x, p.y, 10, 0, 6.28); ctx.fill(); ctx.fillStyle = '#fff'; ctx.fillRect(p.x - 6, p.y - 2, 12, 4); ctx.fillRect(p.x - 2, p.y - 6, 4, 12) }
                var pc = { speed: '#ff0', shield: '#08f', damage: '#f00', ghost: '#aaa' };
                for (var i = 0; i < powerups.length; i++) { var p = powerups[i]; ctx.fillStyle = pc[p.type] || '#fff'; ctx.beginPath(); ctx.arc(p.x, p.y, 12, 0, 6.28); ctx.fill() }

                for (var i = 0; i < hazards.length; i++) {
                    var h = hazards[i]; if (h.type === 'fire') { ctx.fillStyle = 'rgba(255,100,0,0.4)'; ctx.beginPath(); ctx.arc(h.x, h.y, 50, 0, 6.28); ctx.fill(); ctx.font = 'bold 16px sans-serif'; ctx.fillText('F', h.x, h.y) }
                    else { ctx.strokeStyle = 'rgba(128,0,255,0.6)'; ctx.beginPath(); ctx.arc(h.x, h.y, 40, 0, 6.28); ctx.stroke(); ctx.font = 'bold 14px sans-serif'; ctx.fillText('V', h.x, h.y) }
                }

                if (lightningWarning) { ctx.strokeStyle = 'rgba(255,255,0,0.7)'; ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.arc(lightningWarning.x, lightningWarning.y, 60, 0, 6.28); ctx.stroke(); ctx.setLineDash([]) }
                if (lightningStrike) { ctx.fillStyle = 'rgba(255,255,200,0.8)'; ctx.beginPath(); ctx.arc(lightningStrike.x, lightningStrike.y, 60, 0, 6.28); ctx.fill() }

                for (var id in monsters) {
                    var m = monsters[id]; if (m.hp <= 0) continue;
                    var sc = m.size / 40, cx = 0, cy = 0;
                    for (var i = 0; i < m.path.length; i++) { cx += m.path[i][0] * 12; cy += m.path[i][1] * 12 } cx /= m.path.length; cy /= m.path.length;

                    if (m.trail.length > 1) { for (var t = 0; t < m.trail.length - 1; t++) { ctx.globalAlpha = (t / m.trail.length) * 0.4; ctx.fillStyle = m.color; ctx.beginPath(); ctx.arc(m.trail[t].x, m.trail[t].y, m.size * 0.3, 0, 6.28); ctx.fill() } ctx.globalAlpha = 1 }
                    if (m.effects.speed || m.effects.shield || m.effects.damage || m.effects.ghost) { ctx.globalAlpha = 0.4; ctx.fillStyle = m.effects.shield ? '#08f' : m.effects.speed ? '#ff0' : m.effects.damage ? '#f00' : '#aaa'; ctx.beginPath(); ctx.arc(m.x, m.y, m.size + 10, 0, 6.28); ctx.fill(); ctx.globalAlpha = 1 }

                    ctx.save(); ctx.translate(m.x, m.y); ctx.scale(sc, sc);
                    ctx.fillStyle = m.effects.ghost ? 'rgba(255,255,255,0.3)' : m.color;
                    ctx.beginPath(); ctx.moveTo(m.path[0][0] * 12 - cx, m.path[0][1] * 12 - cy);
                    for (var i = 1; i < m.path.length; i++) ctx.lineTo(m.path[i][0] * 12 - cx, m.path[i][1] * 12 - cy);
                    ctx.closePath(); ctx.fill(); ctx.restore();

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center'; ctx.fillText(Math.ceil(m.hp), m.x, m.y);
                    ctx.font = '10px sans-serif'; ctx.fillText(m.name, m.x, m.y - m.size * 1.5 - 6);
                }

                for (var i = 0; i < particles.length; i++) { var p = particles[i]; ctx.globalAlpha = 1 - p.age / 30; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, 6.28); ctx.fill() } ctx.globalAlpha = 1;
                for (var i = 0; i < blastFx.length; i++) { var b = blastFx[i], a = 1 - b.age / 20; ctx.strokeStyle = 'rgba(255,255,255,' + a + ')'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(b.x, b.y, b.age * 4, 0, 6.28); ctx.stroke() }
                for (var i = 0; i < floatTexts.length; i++) { var f = floatTexts[i]; ctx.globalAlpha = 1 - f.age / 40; ctx.fillStyle = f.color; ctx.font = 'bold 14px sans-serif'; ctx.fillText(f.text, f.x, f.y - f.age); ctx.globalAlpha = 1 }

                var m = monsters[0];
                if (m) {
                    var bBtn = document.getElementById('blastBtn'), aBtn = document.getElementById('abilityBtn');
                    if (m.hp <= 0) {
                        if (bBtn) bBtn.textContent = 'Dead';
                        if (aBtn) aBtn.textContent = 'Dead';
                    } else {
                        if (bBtn) bBtn.textContent = 'Blast' + ((blastCooldown > 0) ? ' (' + Math.ceil(blastCooldown / 60) + ')' : '');
                        if (aBtn) aBtn.textContent = m.ability === 'none' ? 'No Ability' : (m.ability.toUpperCase() + ((m.abilityCooldown > 0) ? ' (' + Math.ceil(m.abilityCooldown / 60) + ')' : ''));
                    }
                }
            }
            var isScotty = false;
            var menu = document.getElementById('menu'), ui = document.getElementById('ui'), arena = document.getElementById('arena'), c = document.getElementById('c'), ac = document.getElementById('ac');
            var start1 = document.getElementById('start1'), start3 = document.getElementById('start3'), start5 = document.getElementById('start5'), clearBtn = document.getElementById('clear'), doneBtn = document.getElementById('done'), restartBtn = document.getElementById('restart');
            var blastBtn = document.getElementById('blastBtn'), abilityBtn = document.getElementById('abilityBtn'), loadScottyBtn = document.getElementById('loadScotty');

            function startGame(nb) { numBots = nb; menu.style.display = 'none'; ui.style.display = 'block'; c.style.display = 'block'; path = []; var ctx = c.getContext('2d'); ctx.fillStyle = '#1a1a24'; ctx.fillRect(0, 0, 300, 300) }
            if (start1) start1.onclick = function () { startGame(1) };
            if (start3) start3.onclick = function () { startGame(3) };
            if (start5) start5.onclick = function () { startGame(5) };

            function getXY(e) { var r = c.getBoundingClientRect(), sx = 300 / r.width, sy = 300 / r.height, px = (e.touches ? e.touches[0].clientX : e.clientX) - r.left, py = (e.touches ? e.touches[0].clientY : e.clientY) - r.top; return { x: clamp(px * sx, 5, 295), y: clamp(py * sy, 5, 295) } }
            function smooth(p) { for (var k = 0; k < 2; k++) { var n = []; for (var i = 0; i < p.length; i++) { var a = p[i - 1] || p[0], b = p[i], cc = p[i + 1] || p[p.length - 1]; n.push({ x: (a.x + b.x * 2 + cc.x) / 4, y: (a.y + b.y * 2 + cc.y) / 4 }) } p = n } return p }
            function onDown(e) { isScotty = false; var p = getXY(e); path = [p] }
            function onMove(e) { if (!path.length) return; var p = getXY(e); path.push(p); var d = smooth(path.slice()), ctx = c.getContext('2d'); ctx.fillStyle = '#1a1a24'; ctx.fillRect(0, 0, 300, 300); ctx.strokeStyle = myColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(d[0].x, d[0].y); for (var i = 1; i < d.length; i++)ctx.lineTo(d[i].x, d[i].y); ctx.stroke() }
            function onUp() { if (path.length < 10) return; path = smooth(path); var g = Math.hypot(path[0].x - path[path.length - 1].x, path[0].y - path[path.length - 1].y); if (g > 5) { var s = Math.ceil(g / 10), ex = path[path.length - 1].x, ey = path[path.length - 1].y; for (var i = 1; i <= s; i++) { var t = i / s; path.push({ x: ex * (1 - t) + path[0].x * t, y: ey * (1 - t) + path[0].y * t }) } } path.push({ x: path[0].x, y: path[0].y }); document.getElementById('drawStatus').textContent = 'Shape ready!'; document.getElementById('drawStatus').style.color = '#2ecc71'; var ctx = c.getContext('2d'); ctx.fillStyle = '#1a1a24'; ctx.fillRect(0, 0, 300, 300); ctx.fillStyle = myColor; ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y); for (var i = 1; i < path.length; i++)ctx.lineTo(path[i].x, path[i].y); ctx.fill() }

            c.addEventListener('touchstart', function (e) { e.preventDefault(); onDown(e) }); c.addEventListener('touchmove', function (e) { e.preventDefault(); onMove(e) }); c.addEventListener('touchend', function (e) { e.preventDefault(); onUp() });
            c.addEventListener('mousedown', onDown); c.addEventListener('mousemove', function (e) { if (e.buttons) onMove(e) }); c.addEventListener('mouseup', onUp);
            clearBtn.onclick = function () { path = []; var ctx = c.getContext('2d'); ctx.fillStyle = '#1a1a24'; ctx.fillRect(0, 0, 300, 300); document.getElementById('drawStatus').textContent = 'Draw your monster'; document.getElementById('drawStatus').style.color = '#888' };
            if (loadScottyBtn) loadScottyBtn.onclick = function () {
                path = [
                    { x: 270, y: 115 },  // Nose tip
                    { x: 255, y: 105 },  // Top of muzzle
                    { x: 248, y: 92 },   // Forehead
                    { x: 240, y: 58 },   // Front ear outer
                    { x: 232, y: 46 },   // Front ear tip
                    { x: 225, y: 65 },   // Front ear inner
                    { x: 218, y: 72 },   // Between ears
                    { x: 212, y: 65 },   // Back ear inner
                    { x: 205, y: 46 },   // Back ear tip
                    { x: 198, y: 70 },   // Back ear outer
                    { x: 192, y: 100 },  // Back of skull
                    { x: 186, y: 118 },  // Neck
                    { x: 110, y: 125 },  // Back topline
                    { x: 78, y: 118 },   // Before tail
                    { x: 58, y: 68 },    // Tail tip
                    { x: 64, y: 105 },   // Tail back edge
                    { x: 68, y: 148 },   // Rump
                    { x: 76, y: 188 },   // Upper hind leg
                    { x: 80, y: 228 },   // Hind foot back
                    { x: 102, y: 228 },  // Hind foot front
                    { x: 108, y: 198 },  // Hind leg top
                    { x: 198, y: 195 },  // Belly / skirt
                    { x: 215, y: 205 },  // Front leg back
                    { x: 220, y: 228 },  // Front foot back
                    { x: 240, y: 228 },  // Front foot front
                    { x: 242, y: 192 },  // Chest lower
                    { x: 250, y: 165 },  // Chest
                    { x: 262, y: 152 },  // Beard lower
                    { x: 272, y: 135 },  // Under chin
                ];
                // Skip smoothing
                path.push({ x: path[0].x, y: path[0].y });
                isScotty = true;
                var ctx = c.getContext('2d'); ctx.fillStyle = '#1a1a24'; ctx.fillRect(0, 0, 300, 300);
                ctx.fillStyle = myColor; ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y); for (var i = 1; i < path.length; i++)ctx.lineTo(path[i].x, path[i].y); ctx.fill();
                document.getElementById('drawStatus').textContent = 'Scotty Loaded!'; document.getElementById('drawStatus').style.color = '#c0392b';
            };

            function genBot(cx, cy) {
                var p = [], r = rand(30, 70), pts = Math.floor(rand(5, 12));
                for (var i = 0; i < pts; i++) { var a = i / pts * 6.28, rr = r + rand(-15, 25); p.push([Math.round((cx + Math.cos(a) * rr) / 12), Math.round((cy + Math.sin(a) * rr) / 12)]) }
                return p
            }

            doneBtn.onclick = function () {
                if (path.length < 10) return;
                var mx = 1e9, my = 1e9, Mx = 0, My = 0; for (var i = 0; i < path.length; i++) { mx = Math.min(mx, path[i].x); my = Math.min(my, path[i].y); Mx = Math.max(Mx, path[i].x); My = Math.max(My, path[i].y) }
                var sw = Mx - mx || 1, sh = My - my || 1, sc = Math.min(220 / sw, 220 / sh), ox = 150 - (mx + Mx) / 2 * sc, oy = 150 - (my + My) / 2 * sc;
                var p = [], ns = Math.min(path.length, 30); for (var i = 0; i < ns; i++) { var j = Math.floor(i * (path.length - 1) / (ns - 1)); p.push([Math.round((path[j].x * sc + ox) / 12), Math.round((path[j].y * sc + oy) / 12)]) }

                ui.style.display = 'none'; arena.style.display = 'flex'; logEl.innerHTML = '';
                monsters = {}; packs = []; powerups = []; hazards = []; particles = []; blastFx = []; floatTexts = []; activeBlasts = [];
                bounds = [0, 0, W, H]; tickCount = 0; suddenDeath = false; blastCooldown = 0;

                monsters[0] = initMonster(0, p, myColor, 'You', false);
                for (var i = 0; i < numBots; i++) monsters[i + 1] = initMonster(i + 1, genBot(150, 150), aiColors[i % 5], 'Bot' + (i + 1), true);

                spawnPack(); spawnPack();
                addLog('Battle Start! ' + numBots + ' bots vs You!');

                if (gameLoop) clearInterval(gameLoop);
                gameLoop = setInterval(update, 16);
            };

            var blastCooldown = 0, keys = {};
            document.addEventListener('keydown', function (e) { keys[e.key] = true }); document.addEventListener('keyup', function (e) { keys[e.key] = false });
            if (blastBtn) blastBtn.onclick = function () { if (!monsters[0] || blastCooldown > 0) return; blast(0); blastCooldown = 180 };
            if (abilityBtn) abilityBtn.onclick = function () { if (!monsters[0]) return; useAbility(0) };

            setInterval(function () {
                if (monsters[0] && monsters[0].hp > 0 && !gameLoop) return;
                if (blastCooldown > 0) blastCooldown--;
                if (monsters[0] && monsters[0].hp > 0) {
                    var m = monsters[0], sp = m.speed;
                    if (keys.ArrowUp || keys.w || keys.W) m.vy -= sp * 0.15; if (keys.ArrowDown || keys.s || keys.S) m.vy += sp * 0.15;
                    if (keys.ArrowLeft || keys.a || keys.A) m.vx -= sp * 0.15; if (keys.ArrowRight || keys.d || keys.D) m.vx += sp * 0.15;
                    if (keys[' '] && blastCooldown <= 0) blastBtn.click();
                    if (keys.Shift || keys.e || keys.E) abilityBtn.click();
                }
            }, 16);
            if (restartBtn) restartBtn.onclick = function () { arena.style.display = 'none'; menu.style.display = 'block'; path = []; };
        })();
    </script>
</body>

</html>