<!DOCTYPE html>
<html>

<head>
    <meta charset=utf-8>
    <meta name=viewport content="width=device-width,initial-scale=1,user-scalable=no">
    <title>Shadow Puppet Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        body {
            background: radial-gradient(ellipse at 50% 40%, #1a1028 0%, #0d0d12 60%, #080810 100%);
            color: #e0e0e0;
            font: 14px sans-serif;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            -webkit-overflow-scrolling: touch
        }

        #lobby {
            text-align: center;
            padding: 15px;
            width: 100%;
            max-width: 500px
        }

        #lobby input,
        #lobby button {
            font-size: 16px;
            padding: 10px;
            margin: 5px;
            border-radius: 6px;
            border: 1px solid #444
        }

        #lobby button {
            background: #4a2d8e;
            color: #fff;
            cursor: pointer
        }

        #qr {
            display: none;
            margin: 10px;
            background: #fff;
            padding: 8px;
            border-radius: 8px
        }

        #c {
            background: #1a1a24;
            border-radius: 8px;
            display: none;
            cursor: crosshair;
            max-width: 90vw;
            max-height: 50vh;
            border: 2px solid #333;
            touch-action: none
        }

        #ui {
            display: none;
            padding: 10px;
            text-align: center;
            width: 100%;
            max-width: 600px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch
        }

        #ui input,
        #ui button {
            font-size: 14px;
            padding: 8px;
            margin: 4px;
            border-radius: 6px;
            border: 1px solid #444
        }

        #ui button {
            background: #4a2d8e;
            color: #fff
        }

        #arena {
            display: none;
            width: 100%;
            flex: 1;
            flex-direction: column;
            align-items: center;
            padding-top: 10px;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            min-height: 0
        }

        #ac {
            background: #1a1a24;
            border-radius: 8px;
            max-width: 100%;
            max-height: 55vh;
            touch-action: pan-y;
            will-change: transform;
            image-rendering: auto
        }

        #qrDraw {
            display: none;
            margin: 5px
        }

        #controls {
            display: flex;
            gap: 8px;
            align-items: stretch;
            margin: 8px 0;
            width: 90%;
            max-width: 500px;
            justify-content: center
        }

        #controls button {
            flex: 1;
            max-width: 200px;
            border: none;
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            padding: 8px 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            transition: opacity 0.2s
        }

        #controls button:disabled {
            opacity: 0.4;
            cursor: default
        }

        #controls button .btn-label {
            font-size: 14px
        }

        #controls button .btn-desc {
            font-size: 9px;
            opacity: 0.7;
            font-weight: normal
        }

        #controls button .btn-cd {
            font-size: 11px;
            opacity: 0.8
        }

        #blastBtn {
            background: linear-gradient(135deg, #e74c3c, #c0392b)
        }

        #abilityBtn {
            background: linear-gradient(135deg, #8e44ad, #6c3483)
        }

        #log {
            font-size: 11px;
            color: #aaa;
            max-height: 60px;
            overflow-y: auto;
            width: 90%;
            text-align: left;
            padding: 6px;
            background: rgba(15, 15, 25, 0.8);
            border-radius: 6px;
            margin-top: 4px
        }

        .hint {
            font-size: 11px;
            color: #888;
            margin: 4px
        }

        #clear {
            background: #555
        }

        /* Mobile responsive styles */
        @media (max-width: 600px) {
            body {
                justify-content: flex-start;
                padding-top: 10px
            }

            #lobby h1 {
                font-size: 22px
            }

            #c {
                max-width: 85vw;
                max-height: 40vh
            }

            #ac {
                max-height: 45vh;
                width: 100%
            }

            #controls {
                width: 95%;
                gap: 6px
            }

            #controls button {
                padding: 10px 4px;
                font-size: 12px
            }

            #controls button .btn-label {
                font-size: 13px
            }

            #log {
                max-height: 80px;
                width: 95%;
                font-size: 10px
            }

            #ui {
                padding: 6px
            }

            #ui input,
            #ui button {
                font-size: 13px;
                padding: 6px;
                margin: 3px
            }

            #statsPanel {
                max-width: 90vw !important;
                font-size: 10px !important
            }

            #arena {
                padding-top: 5px;
                padding-bottom: 10px
            }
        }

        @media (max-height: 600px) {
            #c {
                max-height: 35vh
            }

            #ac {
                max-height: 40vh
            }

            #statsPanel {
                font-size: 9px !important
            }
        }
    </style>
</head>

<body>
    <div id=lobby>
        <h1>Shadow Puppet Arena</h1>
        <p style=margin:8px>Draw a shape. Up to 6 players!</p><button id=create>Create Game</button><br><input id=code
            placeholder="Room code" maxlength=4 style=text-transform:uppercase><button id=join>Join</button>
        <div id=qr></div>
        <p id=msg style=margin-top:15px;color:#888>Connecting...</p>
    </div>
    <div id=ui style=display:none>
        <p id=room>Room: ---</p>
        <div id=qrDraw></div>
        <p id=count></p><input id=mname placeholder="Name your shape" maxlength=12><br><canvas id=c width=300
            height=300></canvas>
        <p class=hint>Draw in ONE stroke. Shape will auto-close.</p>
        <div id=statsPanel style="margin:6px;padding:8px;background:rgba(20,20,35,0.9);border-radius:8px;border:1px solid #444;font-size:11px;display:none;max-width:320px;text-align:left">
            <div style="font-weight:bold;text-align:center;color:#ccc;margin-bottom:4px">Shape Analysis</div>
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:3px 10px">
                <div>üìê <b>Area</b>: <span id=statArea>-</span></div>
                <div style=color:#888;font-size:10px>‚Üí HP (compact shape=more)</div>
                <div>üìê <b>Corners</b>: <span id=statCorners>-</span></div>
                <div style=color:#888;font-size:10px>‚Üí Spikes/Dmg dealt</div>
                <div>‚öñ <b>Symmetry</b>: <span id=statSym>-</span></div>
                <div style=color:#888;font-size:10px>‚Üí Stability/Defense</div>
                <div>ü¶µ <b>Protrusions</b>: <span id=statLegs>-</span></div>
                <div style=color:#888;font-size:10px>‚Üí Base speed (long spikes/limbs)</div>
            </div>
            <div style="margin-top:6px;padding-top:5px;border-top:1px solid #333">
                <div style="text-align:center"><b>Ability:</b> <span id=statAbility style=color:#9b59b6>-</span></div>
                <div id=statAbilityRule style="text-align:center;color:#666;font-size:10px;margin-top:2px"></div>
            </div>
            <div style="margin-top:4px;padding-top:4px;border-top:1px solid #222;color:#666;font-size:9px;text-align:center">
                üé≤ Ability is random: ‚ö° Dash (speed burst) &nbsp;|
                üõ° Block (invincible 4s) &nbsp;|
                üíö Absorb (reflect hits &amp; heal 2s)
            </div>
        </div>
        <p id=drawStatus style=margin:4px>Draw your monster</p><button id=loadPrev
            style=display:none;background:#2980b9>Load Previous</button><button id=loadScotty
            style=background:#c0392b;margin-left:4px>Load Scotty üêï</button><button id=clear>Clear</button><button
            id=done>Ready!</button><button id=unready style=display:none;background:#666>Unready</button>
    </div>
    <div id=arena><canvas id=ac width=900 height=640></canvas>
        <div id=controls>
            <button id=blastBtn><span class=btn-label>üí® Blast</span><span class=btn-desc>Push all nearby</span><span class=btn-cd>Ready</span></button>
            <button id=abilityBtn><span class=btn-label>Ability</span><span class=btn-desc></span><span class=btn-cd></span></button>
        </div>
        <div id=log></div>
        <div style="height:20px;flex-shrink:0"></div>
    </div>
    <script>
        (function () {
            var lobby = document.getElementById('lobby'), ui = document.getElementById('ui'), arena = document.getElementById('arena'), c = document.getElementById('c'), ac = document.getElementById('ac'), msg = document.getElementById('msg'), room = document.getElementById('room'), count = document.getElementById('count'), qr = document.getElementById('qr'), done = document.getElementById('done'), unready = document.getElementById('unready'), log = document.getElementById('log'), blastBtn = document.getElementById('blastBtn'), clearBtn = document.getElementById('clear'), loadPrevBtn = document.getElementById('loadPrev'), loadScottyBtn = document.getElementById('loadScotty'), abilityBtn = document.getElementById('abilityBtn');
            var W = 300, H = 300, path = [], playerId = 0, myColor = '#6a4c93', monsters = {}, packs = [], powerups = [], hazards = [], particles = [], ws, isReady = false, bounds = [0, 0, 900, 640];
            var blastCooldown = 0, abilityCooldown = 0, blastFx = [], floatTexts = [], isDead = false, hasSavedShape = false, savedPath = [];
            var lightningWarning = null, lightningStrike = null, suddenDeath = false, myAbility = 'none', isScotty = false;
            var arenaDirty = false, cachedBgGrad = null, cachedAreaGrad = null, lastBounds = null;
            var WS_URL = (location.protocol === 'https:' ? 'wss:' : 'ws:') + '//' + (location.host || 'localhost:3000');
            var retries = 0;
            function post(m) { msg.textContent = m; msg.style.color = '#888' }
            function postErr(m) { msg.textContent = m; msg.style.color = '#e66' }
            function addLog(t) { log.innerHTML += '<div>' + t + '</div>'; log.scrollTop = log.scrollHeight }
            function connect() {
                post(retries ? 'Retrying...' : 'Connecting...'); ws = new WebSocket(WS_URL);
                ws.onopen = function () { retries = 0; post('Connected!'); var r = null, u = new URL(location.href); if (u.searchParams.get('room')) r = u.searchParams.get('room'); var m = location.pathname.match(/\/join\/([A-Za-z]{4})/i); if (m) r = m[1]; if (r) { var code = r.toUpperCase().slice(0, 4); document.getElementById('code').value = code; ws.send(JSON.stringify({ t: 'join', code: code })) } };
                ws.onclose = function () { postErr('Disconnected.' + (retries < 5 ? ' Retrying...' : ' Refresh.')); if (retries < 5) { retries++; setTimeout(connect, 3000) } };
                ws.onmessage = function (e) {
                    var d = JSON.parse(e.data);
                    if (d.t === 'code') { room.textContent = 'Room: ' + d.code; var joinUrl = location.origin + '/join/' + d.code; var qrUrl = 'https://api.qrserver.com/v1/create-qr-code/?size=160x160&data=' + encodeURIComponent(joinUrl); qr.innerHTML = '<img src="' + qrUrl + '" alt=QR>'; qr.style.display = 'block'; document.getElementById('qrDraw').innerHTML = '<img src="' + qrUrl + '" alt=QR style=background:#fff;padding:4px;border-radius:6px>'; document.getElementById('qrDraw').style.display = 'block'; post('Share QR or code: ' + d.code) }
                    else if (d.t === 'joined') { count.textContent = (d.count || 0) + ' players'; post('Player joined!') }
                    else if (d.t === 'status') { count.textContent = d.ready + '/' + d.total + ' ready' }
                    else if (d.t === 'start') { lobby.style.display = 'none'; ui.style.display = 'block'; c.style.display = 'block'; playerId = d.id; if (d.color) myColor = d.color }
                    else if (d.t === 'arena') {
                        monsters = d.m; packs = d.pk || []; powerups = d.pu || []; hazards = d.hz || []; particles = d.pt || [];
                        if (d.b) bounds = d.b;
                        if (d.bl) for (var bi = 0; bi < d.bl.length; bi++) blastFx.push({ x: d.bl[bi].x, y: d.bl[bi].y, age: 0 });
                        if (d.ft) for (var fi = 0; fi < d.ft.length; fi++) floatTexts.push({ x: d.ft[fi].x, y: d.ft[fi].y, text: d.ft[fi].text, color: d.ft[fi].color, age: 0 });
                        arenaDirty = true;
                        lightningWarning = d.lw; lightningStrike = d.ls; suddenDeath = d.sd;
                        lobby.style.display = 'none'; ui.style.display = 'none'; arena.style.display = 'flex';
                        if (d.log) for (var i = 0; i < d.log.length; i++) addLog(d.log[i]);
                        if (!monsters[playerId] && !isDead) { isDead = true; blastBtn.disabled = true; blastBtn.style.background = '#333'; abilityBtn.disabled = true; abilityBtn.style.background = '#333'; }
                        else if (monsters[playerId]) { myAbility = monsters[playerId].ability || 'none'; }
                        renderArena()
                    }
                    else if (d.t === 'restart') { isDead = false; hasSavedShape = true; if (path.length > 3) savedPath = path.slice(); arena.style.display = 'none'; ui.style.display = 'block'; c.style.display = 'block'; isReady = false; done.style.display = 'inline-block'; unready.style.display = 'none'; blastBtn.disabled = false; blastBtn.style.background = ''; blastCooldown = 0; abilityCooldown = 0; abilityBtn.disabled = false; abilityBtn.style.background = ''; blastFx = []; floatTexts = []; lightningWarning = null; lightningStrike = null; particles = []; if (savedPath.length > 3) { loadPrevBtn.style.display = 'inline-block'; document.getElementById('drawStatus').textContent = 'Load previous shape or draw new'; } else { document.getElementById('drawStatus').textContent = 'Draw your monster'; } document.getElementById('drawStatus').style.color = '#888'; if (path.length > 3) drawMonster() }
                    else if (d.t === 'full') { postErr('Room full') }
                    else if (d.t === 'invalid') { postErr('Invalid code') }
                }
            }
            function createGame() { if (ws && ws.readyState === 1) ws.send(JSON.stringify({ t: 'create' })); else postErr('Connecting...') }
            function joinGame() {
                var code = document.getElementById('code').value.toUpperCase().slice(0, 4); if (!code || code.length < 4) { postErr('Code is 4 letters'); return }
                ws.send(JSON.stringify({ t: 'join', code: code }))
            }
            document.getElementById('create').onclick = createGame;
            document.getElementById('join').onclick = joinGame;
            function analyze() {
                var p = path;
                var pts = []; for (var i = 0; i < p.length; i++) pts.push({ x: p[i].x, y: p[i].y });
                // Compute curvature at each point to identify sharp features (gear teeth etc)
                var curvatures = [];
                for (var i = 0; i < pts.length; i++) {
                    var prev = pts[(i - 1 + pts.length) % pts.length], cur = pts[i], next = pts[(i + 1) % pts.length];
                    var a2 = Math.atan2(next.y - cur.y, next.x - cur.x), b2 = Math.atan2(cur.y - prev.y, cur.x - prev.x);
                    var diff2 = Math.abs(a2 - b2); if (diff2 > Math.PI) diff2 = 2 * Math.PI - diff2;
                    curvatures.push(diff2);
                }
                // Downsample for stats: keep up to 30 evenly-spaced points
                var statPts = pts;
                if (pts.length > 35) { var np = []; for (var i = 0; i < 30; i++)np.push(pts[Math.floor(i * (pts.length - 1) / 29)]); statPts = np }
                var statN = statPts.length;
                if (statN > 2 && Math.hypot(statPts[0].x - statPts[statN - 1].x, statPts[0].y - statPts[statN - 1].y) < 5) statN--;
                var corners = 0; for (var i = 0; i < statN; i++) {
                    var prev = statPts[(i - 1 + statN) % statN], cur = statPts[i], next = statPts[(i + 1) % statN];
                    var a = Math.atan2(next.y - cur.y, next.x - cur.x), b = Math.atan2(cur.y - prev.y, cur.x - prev.x);
                    var diff = Math.abs(a - b); if (diff > Math.PI) diff = 2 * Math.PI - diff; if (diff > 1.0) corners++
                }
                var cx = 0, cy = 0; for (var i = 0; i < statPts.length; i++) { cx += statPts[i].x; cy += statPts[i].y } cx /= statPts.length; cy /= statPts.length;
                var left = 0, right = 0; for (var i = 0; i < statPts.length; i++) { var v = statPts[i].y - cy; if (statPts[i].x < cx) left += v * v; else right += v * v }
                var sym = Math.min(1, 1 - Math.abs(left - right) / (left + right + 1));
                var segs = []; for (var i = 1; i < statPts.length; i++)segs.push(Math.hypot(statPts[i].x - statPts[i - 1].x, statPts[i].y - statPts[i - 1].y));
                var avg = segs.reduce(function (a, b) { return a + b }, 0) / segs.length; var legs = 0; for (var i = 0; i < segs.length; i++)if (segs[i] > avg * 1.8) legs++;

                var mx = 1e9, my = 1e9, Mx = 0, My = 0; for (var i = 0; i < pts.length; i++) { mx = Math.min(mx, pts[i].x); my = Math.min(my, pts[i].y); Mx = Math.max(Mx, pts[i].x); My = Math.max(My, pts[i].y) }
                var sw = Mx - mx || 1, sh = My - my || 1, sc = Math.min(220 / sw, 220 / sh), ox = 150 - (mx + Mx) / 2 * sc, oy = 150 - (my + My) / 2 * sc;
                // Feature-preserving downsampling: keep high-curvature points (gear teeth, spikes)
                var maxOut = 40;
                var outP = [];
                if (pts.length <= maxOut) {
                    for (var i = 0; i < pts.length; i++) outP.push([Math.round((pts[i].x * sc + ox) / 12), Math.round((pts[i].y * sc + oy) / 12)]);
                } else {
                    // Score each point by curvature; always keep first/last
                    var scored = [];
                    for (var i = 0; i < pts.length; i++) scored.push({ idx: i, c: curvatures[i] || 0 });
                    // Always include evenly spaced base points
                    var keep = {};
                    var baseCount = Math.floor(maxOut * 0.5);
                    for (var i = 0; i < baseCount; i++) keep[Math.floor(i * (pts.length - 1) / (baseCount - 1))] = true;
                    // Fill remaining slots with highest curvature points
                    scored.sort(function(a, b) { return b.c - a.c });
                    var remaining = maxOut - Object.keys(keep).length;
                    for (var i = 0; i < scored.length && remaining > 0; i++) {
                        if (!keep[scored[i].idx]) { keep[scored[i].idx] = true; remaining-- }
                    }
                    var indices = Object.keys(keep).map(Number).sort(function(a,b){return a-b});
                    for (var i = 0; i < indices.length; i++) {
                        var pi = indices[i];
                        outP.push([Math.round((pts[pi].x * sc + ox) / 12), Math.round((pts[pi].y * sc + oy) / 12)]);
                    }
                }
                // Remove duplicate consecutive points
                var cleanP = [outP[0]];
                for (var i = 1; i < outP.length; i++) {
                    if (outP[i][0] !== cleanP[cleanP.length-1][0] || outP[i][1] !== cleanP[cleanP.length-1][1]) cleanP.push(outP[i]);
                }
                outP = cleanP;
                var area = 0; for (var i = 0; i < outP.length; i++) { var j2 = (i + 1) % outP.length; area += outP[i][0] * outP[j2][1] - outP[j2][0] * outP[i][1] } area = Math.abs(area) / 2;
                return { a: area, c: corners, s: sym, l: legs, p: outP, n: (document.getElementById('mname').value || '???').slice(0, 12) }
            }
            function drawMonster() {
                var ctx = c.getContext('2d'), pts = path;
                if (pts.length < 3) return null;
                var stats = analyze();
                ctx.fillStyle = '#1a1a24'; ctx.fillRect(0, 0, W, H);
                ctx.fillStyle = myColor; ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y); for (var i = 1; i < pts.length; i++)ctx.lineTo(pts[i].x, pts[i].y); ctx.closePath(); ctx.fill();
                var name = document.getElementById('mname').value || '';
                if (name) { ctx.fillStyle = '#fff'; ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center'; ctx.fillText(name, W / 2, 20) }
                // Update stats panel
                var sp = document.getElementById('statsPanel'); sp.style.display = 'block';
                document.getElementById('statArea').textContent = stats.a + ' ‚Üí ' + Math.min(150, Math.max(80, Math.round(stats.a * 0.6))) + ' HP';
                document.getElementById('statCorners').textContent = stats.c + ' ‚Üí ' + Math.min(stats.c, 5) + ' spikes';
                document.getElementById('statSym').textContent = (Math.round(stats.s * 100)) + '% ‚Üí ' + Math.min(stats.s * 3, 2).toFixed(1) + ' stability';
                document.getElementById('statLegs').textContent = stats.l + ' ‚Üí ' + (1.0 + Math.min(stats.l * 0.15, 0.5)).toFixed(2) + 'x speed';
                document.getElementById('statAbility').textContent = 'üé≤ Random';
                document.getElementById('statAbilityRule').textContent = 'Randomly assigned: Dash, Block, or Absorb';
                return stats
            }
            var abilityDescs = { dash: 'Speed burst forward', block: 'Invincible 4s', absorb: 'Reflect & heal 2s', none: '' };
            var abilityIcons = { dash: '‚ö°', block: 'üõ°', absorb: 'üíö', none: '' };
            var puLabels = { speed: '2x SPEED', shield: 'SHIELD', damage: '2x DMG', ghost: 'PHASE' };
            var arenaCtx = ac.getContext('2d');
            function rebuildGradients() {
                cachedBgGrad = arenaCtx.createRadialGradient(450, 320, 50, 450, 320, 500);
                cachedBgGrad.addColorStop(0, '#1a1020'); cachedBgGrad.addColorStop(1, '#080810');
                var bw = bounds[2] - bounds[0], bh = bounds[3] - bounds[1];
                cachedAreaGrad = arenaCtx.createRadialGradient(bounds[0] + bw / 2, bounds[1] + bh / 2, 30, bounds[0] + bw / 2, bounds[1] + bh / 2, Math.max(bw, bh) * 0.7);
                cachedAreaGrad.addColorStop(0, '#12121e'); cachedAreaGrad.addColorStop(1, '#0a0a14');
                lastBounds = bounds.slice();
            }
            function drawFire(ctx, x, y) {
                ctx.fillStyle = 'rgba(255,100,0,0.4)'; ctx.beginPath(); ctx.arc(x, y, 50, 0, Math.PI * 2); ctx.fill();
                // Simple flame shape instead of emoji
                ctx.fillStyle = '#f80'; ctx.beginPath(); ctx.moveTo(x, y - 10); ctx.lineTo(x - 6, y + 6); ctx.lineTo(x + 6, y + 6); ctx.closePath(); ctx.fill();
                ctx.fillStyle = '#fc0'; ctx.beginPath(); ctx.moveTo(x, y - 5); ctx.lineTo(x - 3, y + 4); ctx.lineTo(x + 3, y + 4); ctx.closePath(); ctx.fill();
                ctx.fillStyle = 'rgba(255,140,0,0.7)'; ctx.font = 'bold 8px sans-serif'; ctx.textAlign = 'center'; ctx.fillText('BURNS', x, y + 14);
            }
            function drawVortex(ctx, x, y) {
                ctx.strokeStyle = 'rgba(128,0,255,0.6)'; ctx.lineWidth = 3;
                for (var vi = 0; vi < 3; vi++) { ctx.beginPath(); ctx.arc(x, y, 30 + vi * 25, 0, Math.PI * 2); ctx.stroke(); }
                // Simple spiral indicator instead of emoji
                ctx.fillStyle = '#808'; ctx.beginPath(); ctx.arc(x, y, 6, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = 'rgba(180,0,255,0.7)'; ctx.font = 'bold 8px sans-serif'; ctx.textAlign = 'center'; ctx.fillText('PULLS', x, y + 14);
            }
            function renderArena() {
                var ctx = arenaCtx;
                // Rebuild gradients only when bounds change
                if (!lastBounds || lastBounds[0] !== bounds[0] || lastBounds[1] !== bounds[1] || lastBounds[2] !== bounds[2] || lastBounds[3] !== bounds[3]) rebuildGradients();
                ctx.fillStyle = cachedBgGrad; ctx.fillRect(0, 0, 900, 640);
                var bw = bounds[2] - bounds[0], bh = bounds[3] - bounds[1];
                ctx.fillStyle = cachedAreaGrad; ctx.fillRect(bounds[0], bounds[1], bw, bh);
                var isShrunk = bounds[0] > 0 || bounds[1] > 0 || bounds[2] < 900 || bounds[3] < 640;
                ctx.strokeStyle = isShrunk ? '#ff0000' : 'rgba(100,80,140,0.4)'; ctx.lineWidth = isShrunk ? 3 : 1; ctx.strokeRect(bounds[0], bounds[1], bw, bh);

                // Draw hazards
                for (var hi = 0; hi < hazards.length; hi++) {
                    var hz = hazards[hi];
                    if (hz.type === 'fire') { drawFire(ctx, hz.x, hz.y); }
                    else if (hz.type === 'vortex') { drawVortex(ctx, hz.x, hz.y); }
                }
                // Lightning warning/strike
                if (lightningWarning) {
                    ctx.strokeStyle = 'rgba(255,255,0,0.7)'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
                    ctx.beginPath(); ctx.arc(lightningWarning.x, lightningWarning.y, 60, 0, Math.PI * 2); ctx.stroke();
                    ctx.setLineDash([]);
                    // Pulsing warning circle (use bitwise for fast oscillation)
                    var pulse = 0.3 + 0.3 * Math.sin(Date.now() * 0.01);
                    ctx.fillStyle = 'rgba(255,255,0,' + pulse + ')'; ctx.beginPath(); ctx.arc(lightningWarning.x, lightningWarning.y, 60, 0, Math.PI * 2); ctx.fill();
                    // Lightning bolt shape instead of emoji
                    ctx.fillStyle = '#ff0'; ctx.beginPath();
                    var lx = lightningWarning.x, ly = lightningWarning.y;
                    ctx.moveTo(lx - 4, ly - 12); ctx.lineTo(lx + 4, ly - 12); ctx.lineTo(lx + 1, ly - 2); ctx.lineTo(lx + 6, ly - 2);
                    ctx.lineTo(lx - 2, ly + 12); ctx.lineTo(lx + 1, ly + 2); ctx.lineTo(lx - 6, ly + 2); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = '#ff0'; ctx.font = 'bold 10px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText('WARNING', lightningWarning.x, lightningWarning.y + 25);
                }
                if (lightningStrike) {
                    // Bright flash
                    ctx.fillStyle = 'rgba(255,255,200,0.6)'; ctx.beginPath(); ctx.arc(lightningStrike.x, lightningStrike.y, 70, 0, Math.PI * 2); ctx.fill();
                    // Lightning bolt from top - NO shadowBlur (very expensive)
                    ctx.save(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 4;
                    ctx.beginPath();
                    var bx = lightningStrike.x, by = lightningStrike.y;
                    var topY = bounds[1];
                    ctx.moveTo(bx + (Math.random() - 0.5) * 10, topY);
                    var segments = 6;
                    for (var si = 1; si <= segments; si++) {
                        var t = si / segments;
                        var lx = bx + (Math.random() - 0.5) * 40 * (1 - t * 0.7);
                        var ly = topY + (by - topY) * t;
                        ctx.lineTo(lx, ly);
                    }
                    ctx.stroke();
                    // Glow via thicker translucent stroke instead of shadowBlur
                    ctx.lineWidth = 8; ctx.strokeStyle = 'rgba(255,255,0,0.3)';
                    ctx.stroke();
                    // Second thinner bolt
                    ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,100,0.8)';
                    ctx.beginPath(); ctx.moveTo(bx + (Math.random() - 0.5) * 15, topY);
                    for (var si = 1; si <= segments; si++) {
                        var t = si / segments;
                        ctx.lineTo(bx + (Math.random() - 0.5) * 50 * (1 - t * 0.5), topY + (by - topY) * t);
                    }
                    ctx.stroke(); ctx.restore();
                    // Impact glow
                    ctx.fillStyle = 'rgba(255,255,0,0.4)'; ctx.beginPath(); ctx.arc(bx, by, 50, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText('ZAP!', bx, by);
                }

                // Health packs
                for (var pi = 0; pi < packs.length; pi++) {
                    var pk = packs[pi];
                    ctx.fillStyle = '#2ecc71'; ctx.beginPath(); ctx.arc(pk.x, pk.y, 10, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 10px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillRect(pk.x - 6, pk.y - 2, 12, 4); ctx.fillRect(pk.x - 2, pk.y - 6, 4, 12);
                    ctx.fillStyle = '#155d32'; ctx.font = 'bold 9px sans-serif'; ctx.fillText(pk.hp, pk.x, pk.y + 16);
                }
                // Power-ups (use simple shapes instead of emoji)
                var puColors = { speed: '#ff0', shield: '#08f', damage: '#f00', ghost: '#aaa' };
                for (var pi = 0; pi < powerups.length; pi++) {
                    var pu = powerups[pi], puc = puColors[pu.type] || '#fff';
                    // Outer glow
                    ctx.globalAlpha = 0.25;
                    ctx.fillStyle = puc; ctx.beginPath(); ctx.arc(pu.x, pu.y, 20, 0, Math.PI * 2); ctx.fill();
                    ctx.globalAlpha = 1;
                    // Circle
                    ctx.fillStyle = puc; ctx.beginPath(); ctx.arc(pu.x, pu.y, 12, 0, Math.PI * 2); ctx.fill();
                    // Simple icon shapes
                    ctx.fillStyle = '#000'; ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
                    if (pu.type === 'speed') { ctx.beginPath(); ctx.moveTo(pu.x - 4, pu.y - 6); ctx.lineTo(pu.x + 4, pu.y - 6); ctx.lineTo(pu.x + 1, pu.y); ctx.lineTo(pu.x + 5, pu.y); ctx.lineTo(pu.x - 2, pu.y + 7); ctx.lineTo(pu.x, pu.y + 1); ctx.lineTo(pu.x - 5, pu.y + 1); ctx.closePath(); ctx.fill(); }
                    else if (pu.type === 'shield') { ctx.beginPath(); ctx.moveTo(pu.x, pu.y - 7); ctx.lineTo(pu.x + 7, pu.y - 3); ctx.lineTo(pu.x + 5, pu.y + 5); ctx.lineTo(pu.x, pu.y + 8); ctx.lineTo(pu.x - 5, pu.y + 5); ctx.lineTo(pu.x - 7, pu.y - 3); ctx.closePath(); ctx.fill(); }
                    else if (pu.type === 'damage') { ctx.beginPath(); ctx.arc(pu.x, pu.y, 4, 0, Math.PI * 2); ctx.fill(); for (var ri = 0; ri < 6; ri++) { var ra = ri * Math.PI / 3; ctx.beginPath(); ctx.moveTo(pu.x + Math.cos(ra) * 5, pu.y + Math.sin(ra) * 5); ctx.lineTo(pu.x + Math.cos(ra) * 9, pu.y + Math.sin(ra) * 9); ctx.stroke(); } }
                    else { ctx.globalAlpha = 0.6; ctx.beginPath(); ctx.arc(pu.x, pu.y, 6, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; }
                    // Label
                    ctx.fillStyle = puc; ctx.font = 'bold 8px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(puLabels[pu.type] || '', pu.x, pu.y + 20);
                }
                // Monsters
                for (var id in monsters) {
                    var m = monsters[id];
                    if (!m.path || !m.path.length) continue;
                    var sc = m.size / 40;
                    var pcx = 0, pcy = 0; for (var i = 0; i < m.path.length; i++) { pcx += m.path[i][0] * 12; pcy += m.path[i][1] * 12 } pcx /= m.path.length; pcy /= m.path.length;
                    // Trail effect (render every other point for perf)
                    if (m.trail && m.trail.length > 1) {
                        ctx.fillStyle = m.color;
                        for (var ti = 0; ti < m.trail.length - 1; ti += 2) {
                            var alpha = (ti / m.trail.length) * 0.4;
                            ctx.globalAlpha = alpha;
                            ctx.beginPath(); ctx.arc(m.trail[ti].x, m.trail[ti].y, m.size * 0.3 * (ti / m.trail.length), 0, Math.PI * 2); ctx.fill();
                        }
                        ctx.globalAlpha = 1;
                    }
                    // Effect glow + label - compute bounding radius from actual shape vertices
                    if (m.effects && (m.effects.speed || m.effects.shield || m.effects.damage || m.effects.ghost)) {
                        var maxR = 0;
                        for (var ei = 0; ei < m.path.length; ei++) {
                            var edx = (m.path[ei][0] * 12 - pcx) * sc;
                            var edy = (m.path[ei][1] * 12 - pcy) * sc;
                            var er = Math.hypot(edx, edy);
                            if (er > maxR) maxR = er;
                        }
                        var glowR = maxR + 8;
                        ctx.globalAlpha = 0.35;
                        ctx.fillStyle = m.effects.shield ? '#08f' : m.effects.speed ? '#ff0' : m.effects.damage ? '#f00' : '#aaa';
                        ctx.beginPath(); ctx.arc(m.x, m.y, glowR, 0, Math.PI * 2); ctx.fill();
                        ctx.globalAlpha = 1;
                        // Small effect label below monster (text only, no emoji)
                        var eLbl = m.effects.shield ? 'SHIELD' : m.effects.speed ? 'FAST' : m.effects.damage ? '2xDMG' : 'PHASE';
                        var eClr = m.effects.shield ? '#4af' : m.effects.speed ? '#ff0' : m.effects.damage ? '#f66' : '#ccc';
                        ctx.globalAlpha = 0.9;
                        ctx.fillStyle = eClr; ctx.font = 'bold 8px sans-serif'; ctx.textAlign = 'center';
                        ctx.fillText(eLbl, m.x, m.y + maxR + 14);
                        ctx.globalAlpha = 1;
                    }
                    ctx.save(); ctx.translate(m.x, m.y); ctx.scale(sc, sc);
                    ctx.fillStyle = m.effects && m.effects.ghost ? 'rgba(255,255,255,0.3)' : m.color; ctx.beginPath();
                    ctx.moveTo((m.path[0][0] * 12 - pcx), (m.path[0][1] * 12 - pcy));
                    for (var i = 1; i < m.path.length; i++) ctx.lineTo((m.path[i][0] * 12 - pcx), (m.path[i][1] * 12 - pcy));
                    ctx.closePath(); ctx.fill();
                    ctx.restore();
                    ctx.fillStyle = '#fff'; ctx.font = 'bold ' + Math.max(10, Math.round(12 * sc)) + 'px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(Math.ceil(m.hp), m.x, m.y);
                    if (m.name) { ctx.font = Math.max(9, Math.round(10 * sc)) + 'px sans-serif'; ctx.fillText(m.name, m.x, m.y - m.size * 1.5 - 6) }
                }
                // Death explosion particles
                for (var pi = 0; pi < particles.length; pi++) {
                    var p = particles[pi];
                    var alpha = Math.max(0, 1 - p.age / 30);
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI * 2); ctx.fill();
                }
                ctx.globalAlpha = 1;
                // Blast effects
                for (var bi = blastFx.length - 1; bi >= 0; bi--) {
                    var bf = blastFx[bi]; bf.age++;
                    var r = bf.age * 4; var alpha = Math.max(0, 1 - bf.age / 20);
                    ctx.strokeStyle = 'rgba(255,255,255,' + alpha + ')'; ctx.lineWidth = Math.max(1, 4 - bf.age * 0.15);
                    ctx.beginPath(); ctx.arc(bf.x, bf.y, r, 0, Math.PI * 2); ctx.stroke();
                    ctx.strokeStyle = 'rgba(255,255,255,' + (alpha * 0.5) + ')'; ctx.beginPath(); ctx.arc(bf.x, bf.y, r * 0.6, 0, Math.PI * 2); ctx.stroke();
                    if (bf.age > 20) blastFx.splice(bi, 1);
                }
                // Float texts
                for (var fi = floatTexts.length - 1; fi >= 0; fi--) {
                    var ft = floatTexts[fi]; ft.age++;
                    ctx.globalAlpha = Math.max(0, 1 - ft.age / 40);
                    ctx.fillStyle = ft.color; ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center';
                    ctx.fillText(ft.text, ft.x, ft.y - ft.age * 0.8);
                    ctx.globalAlpha = 1;
                    if (ft.age > 40) floatTexts.splice(fi, 1);
                }
                updateButtons();
            }
            function updateButtons() {
                if (isDead) {
                    blastBtn.innerHTML = '<span class=btn-label>Dead</span>';
                    abilityBtn.innerHTML = '<span class=btn-label>Dead</span>';
                    return;
                }
                var bcdText = blastCooldown > 0 ? blastCooldown + 's' : 'Ready';
                blastBtn.innerHTML = '<span class=btn-label>üí® Blast</span><span class=btn-desc>Push all nearby</span><span class=btn-cd>' + bcdText + '</span>';
                var abName = myAbility === 'none' ? 'No Ability' : (abilityIcons[myAbility] || '') + ' ' + myAbility.charAt(0).toUpperCase() + myAbility.slice(1);
                var abDesc = abilityDescs[myAbility] || '';
                var acdText = myAbility === 'none' ? '' : (abilityCooldown > 0 ? abilityCooldown + 's' : 'Ready');
                abilityBtn.innerHTML = '<span class=btn-label>' + abName + '</span><span class=btn-desc>' + abDesc + '</span><span class=btn-cd>' + acdText + '</span>';
            }
            done.onclick = function () {
                if (hasSavedShape && path.length < 10) {
                    ws.send(JSON.stringify({ t: 'monster', reuse: true })); isReady = true; done.style.display = 'none'; unready.style.display = 'inline-block'; document.getElementById('drawStatus').textContent = 'Ready! Waiting for others...'; return
                }
                if (path.length < 10) { document.getElementById('drawStatus').textContent = 'Draw a shape first'; document.getElementById('drawStatus').style.color = '#e66'; return }
                var s = drawMonster(); if (!s) { document.getElementById('drawStatus').textContent = 'Draw a valid shape'; document.getElementById('drawStatus').style.color = '#e66'; return }
                hasSavedShape = false; savedPath = path.slice(); ws.send(JSON.stringify({ t: 'monster', m: s })); isReady = true; done.style.display = 'none'; unready.style.display = 'inline-block'; loadPrevBtn.style.display = 'none'; document.getElementById('drawStatus').textContent = 'Ready! Waiting for others...'
            };
            unready.onclick = function () {
                ws.send(JSON.stringify({ t: 'unready' })); isReady = false; unready.style.display = 'none'; done.style.display = 'inline-block'; document.getElementById('drawStatus').textContent = 'Draw your shape'
            };
            clearBtn.onclick = function () {
                if (isReady) return;
                path = [];
                var ctx = c.getContext('2d'); ctx.fillStyle = '#1a1a24'; ctx.fillRect(0, 0, W, H);
                document.getElementById('drawStatus').textContent = 'Draw your shape'; document.getElementById('drawStatus').style.color = '#888'
            };
            loadPrevBtn.onclick = function () {
                if (isReady || savedPath.length < 10) return;
                path = savedPath.slice();
                drawMonster();
                document.getElementById('drawStatus').textContent = 'Previous shape loaded!'; document.getElementById('drawStatus').style.color = '#2ecc71'
            };
            loadScottyBtn.onclick = function () {
                if (isReady) return;
                // Scotty dog path (approximate profile)
                path = [
                    { x: 280, y: 130 }, // Nose Tip
                    { x: 280, y: 160 }, { x: 260, y: 190 }, { x: 245, y: 170 }, // Beard
                    { x: 230, y: 200 }, // Chest
                    { x: 230, y: 260 }, { x: 210, y: 260 }, { x: 210, y: 220 }, // Front Leg
                    { x: 190, y: 220 }, { x: 130, y: 220 }, // Belly
                    { x: 120, y: 260 }, { x: 90, y: 260 }, { x: 90, y: 210 }, // Back Leg
                    { x: 60, y: 180 }, // Rump
                    { x: 50, y: 130 }, { x: 45, y: 80 }, { x: 65, y: 120 }, // Tail
                    { x: 90, y: 130 }, { x: 190, y: 130 }, // Back
                    { x: 195, y: 70 }, { x: 205, y: 40 }, { x: 215, y: 70 }, // Ear Back
                    { x: 220, y: 70 }, { x: 230, y: 40 }, { x: 240, y: 70 }, // Ear Front
                    { x: 250, y: 90 }, // Forehead
                    { x: 255, y: 110 }, // Stop
                    { x: 280, y: 110 }  // Snout Top
                ];
                // Skip smoothing for defined features
                path.push({ x: path[0].x, y: path[0].y }); // Close
                isScotty = true;
                document.getElementById('mname').value = 'Scotty';
                drawMonster();
                document.getElementById('drawStatus').textContent = 'Scotty Loaded!'; document.getElementById('drawStatus').style.color = '#c0392b';
            };
            function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)) }
            function getXY(e) { var r = c.getBoundingClientRect(), sx = W / r.width, sy = H / r.height; var px = (e.touches ? e.touches[0].clientX : e.clientX) - r.left, py = (e.touches ? e.touches[0].clientY : e.clientY) - r.top; return { x: clamp(px * sx, 5, W - 5), y: clamp(py * sy, 5, H - 5) } }
            function onDown(e) { if (isReady) return; isScotty = false; var p = getXY(e); path = [p] }
            function smooth(p) {
                // Adaptive smoothing: preserve sharp corners (gear teeth, spikes)
                for (var k = 0; k < 2; k++) {
                    var n = [];
                    for (var i = 0; i < p.length; i++) {
                        var a = p[i - 1] || p[0], b = p[i], cc = p[i + 1] || p[p.length - 1];
                        // Measure angle change at this point
                        var ang1 = Math.atan2(b.y - a.y, b.x - a.x);
                        var ang2 = Math.atan2(cc.y - b.y, cc.x - b.x);
                        var angDiff = Math.abs(ang1 - ang2); if (angDiff > Math.PI) angDiff = 2 * Math.PI - angDiff;
                        // Sharp corner (>45 deg): reduce smoothing to preserve detail
                        var weight = angDiff > 0.8 ? 6 : 2;
                        n.push({ x: (a.x + b.x * weight + cc.x) / (weight + 2), y: (a.y + b.y * weight + cc.y) / (weight + 2) });
                    }
                    p = n;
                }
                return p;
            }
            function onMove(e) {
                if (path.length === 0 || isReady) return; var p = getXY(e); path.push(p); var draw = smooth(path.slice()); var ctx = c.getContext('2d'); ctx.fillStyle = '#1a1a24'; ctx.fillRect(0, 0, W, H); ctx.strokeStyle = myColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(draw[0].x, draw[0].y); for (var i = 1; i < draw.length; i++)ctx.lineTo(draw[i].x, draw[i].y); ctx.stroke();
                if (draw.length > 5) { var d = Math.hypot(draw[0].x - draw[draw.length - 1].x, draw[0].y - draw[draw.length - 1].y); ctx.strokeStyle = d < 50 ? 'rgba(46,204,113,0.5)' : 'rgba(231,76,60,0.3)'; ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(draw[draw.length - 1].x, draw[draw.length - 1].y); ctx.lineTo(draw[0].x, draw[0].y); ctx.stroke(); ctx.setLineDash([]) }
            }
            function onUp() {
                if (path.length < 10 || isReady) return; path = smooth(path);
                var gap = Math.hypot(path[0].x - path[path.length - 1].x, path[0].y - path[path.length - 1].y);
                if (gap > 5) { var steps = Math.max(2, Math.ceil(gap / 10)); var ex = path[path.length - 1].x, ey = path[path.length - 1].y; for (var i = 1; i <= steps; i++) { var t = i / steps; path.push({ x: ex * (1 - t) + path[0].x * t, y: ey * (1 - t) + path[0].y * t }) } }
                path.push({ x: path[0].x, y: path[0].y });
                document.getElementById('drawStatus').textContent = 'Shape ready!'; document.getElementById('drawStatus').style.color = '#2ecc71'; drawMonster()
            }
            c.addEventListener('touchstart', function (e) { e.preventDefault(); onDown(e) });
            c.addEventListener('touchmove', function (e) { e.preventDefault(); onMove(e) });
            c.addEventListener('touchend', function (e) { e.preventDefault(); if (e.touches.length === 0) onUp() });
            c.addEventListener('mousedown', onDown);
            c.addEventListener('mousemove', function (e) { if (e.buttons) onMove(e) });
            c.addEventListener('mouseup', onUp);
            blastBtn.onclick = function () {
                if (blastCooldown > 0 || isDead) return;
                ws.send(JSON.stringify({ t: 'blast' }));
                blastCooldown = 5; blastBtn.disabled = true;
                var cd = setInterval(function () { blastCooldown--; updateButtons(); if (blastCooldown <= 0) { clearInterval(cd); if (!isDead) { blastBtn.disabled = false; blastBtn.style.background = '' } } }, 1000);
                updateButtons();
            };
            abilityBtn.onclick = function () {
                if (abilityCooldown > 0 || isDead || myAbility === 'none') return;
                ws.send(JSON.stringify({ t: 'ability' }));
                abilityCooldown = myAbility === 'dash' ? 8 : 10; abilityBtn.disabled = true;
                var cd = setInterval(function () { abilityCooldown--; updateButtons(); if (abilityCooldown <= 0) { clearInterval(cd); if (!isDead) { abilityBtn.disabled = false; abilityBtn.style.background = '' } } }, 1000);
                updateButtons();
            };
            // Use requestAnimationFrame with dirty flag for efficient rendering
            function arenaLoop() {
                if (arena.style.display === 'flex' && Object.keys(monsters).length) {
                    // Always render if there are active animations, otherwise only on state change
                    if (arenaDirty || blastFx.length > 0 || floatTexts.length > 0 || lightningStrike || lightningWarning) {
                        renderArena();
                        arenaDirty = false;
                    }
                }
                requestAnimationFrame(arenaLoop);
            }
            requestAnimationFrame(arenaLoop);
            connect();
        })();
    </script>
</body>

</html>