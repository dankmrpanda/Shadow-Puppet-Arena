<!DOCTYPE html>
<html>

<head>
    <meta charset=utf-8>
    <meta name=viewport content="width=device-width,initial-scale=1,user-scalable=no">
    <title>Shadow Puppet Arena - Continuous Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0
        }

        body {
            background: #0d0d12;
            color: #e0e0e0;
            font: 14px sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center
        }

        button {
            font-family: inherit;
            cursor: pointer;
            user-select: none
        }

        #menu {
            text-align: center;
            padding: 15px
        }

        #menu button {
            font-size: 16px;
            padding: 12px 24px;
            margin: 8px;
            border-radius: 8px;
            border: none;
            background: linear-gradient(135deg, #6a4c93, #4a2d8e);
            color: #fff;
            box-shadow: 0 4px 15px rgba(106, 76, 147, 0.4)
        }

        #menu button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(106, 76, 147, 0.6)
        }

        #c {
            background: #1a1a24;
            border-radius: 8px;
            cursor: crosshair;
            max-width: 95vw;
            max-height: 50vh;
            border: 2px solid #333;
            display: none
        }

        #ui {
            display: none;
            padding: 10px;
            text-align: center
        }

        #ui button {
            font-size: 14px;
            padding: 8px 16px;
            margin: 4px;
            border-radius: 6px;
            border: 1px solid #444;
            background: #4a2d8e;
            color: #fff
        }

        #arena {
            display: none;
            width: 100%;
            flex: 1;
            flex-direction: column;
            align-items: center;
            padding: 0
        }

        #ac {
            background: #1a1a24;
            width: 100vw;
            height: 70vh
        }

        #nameInput {
            font-size: 16px;
            padding: 6px 12px;
            margin: 6px;
            border-radius: 6px;
            border: 1px solid #444;
            background: #222;
            color: #fff;
            text-align: center;
            width: 180px
        }

        .hint {
            font-size: 11px;
            color: #888;
            margin: 4px
        }

        #clear {
            background: #555
        }

        #log {
            font-size: 11px;
            color: #aaa;
            max-height: 60px;
            overflow-y: auto;
            width: 90%;
            text-align: left;
            padding: 6px;
            background: #151520;
            border-radius: 6px;
            margin-top: 4px
        }

        #blastBtn {
            background: #c0392b;
            color: #fff;
            font-size: 14px;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            margin: 4px
        }

        #blastBtn:disabled {
            background: #555
        }

        #abilityBtn {
            background: #9b59b6;
            color: #fff;
            font-size: 14px;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            margin: 4px
        }

        #abilityBtn:disabled {
            background: #555
        }

        #stopBtn {
            background: #c0392b;
            color: #fff;
            font-size: 16px;
            padding: 10px 24px;
            border: none;
            border-radius: 8px;
            margin: 8px;
            box-shadow: 0 4px 15px rgba(192, 57, 43, 0.4)
        }

        #stopBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(192, 57, 43, 0.6)
        }

        #stats {
            font-size: 12px;
            color: #aaa;
            margin: 6px;
            text-align: center
        }

        #stats span {
            color: #9b59b6;
            font-weight: bold
        }
    </style>
</head>

<body>
    <div id=menu>
        <h1
            style="background:linear-gradient(135deg,#9b59b6,#3498db);-webkit-background-clip:text;-webkit-text-fill-color:transparent;font-size:28px;margin-bottom:10px">
            Shadow Puppet Arena</h1>
        <p style="margin:8px;color:#aaa">Draw a shape. Watch continuous battles!</p>
        <button id=start1>1 vs 1</button>
        <button id=start3>1 vs 3</button>
        <button id=start5>1 vs 5</button>
        <p class=hint style="margin-top:20px">Offline Continuous Simulation</p>
    </div>
    <div id=ui>
        <p id=drawStatus style="margin:4px;color:#888">Draw your monster</p>
        <canvas id=c width=300 height=300></canvas>
        <p class=hint>Draw in ONE stroke. Shape will auto-close.</p>
        <div style="margin:6px"><label style="color:#aaa;font-size:12px">Name / Emoji:</label><br><input id=nameInput type=text placeholder="üëæ You" maxlength=20></div>
        <button id=clear>Clear</button><button id=loadScotty style="background:#c0392b">Load Scotty</button><button id=done>Start Simulation!</button>
    </div>
    <div id=arena>
        <canvas id=ac></canvas>
        <div id=stats>Round: <span id=roundNum>1</span> | Wins: <span id=winCount>0</span> | Losses: <span id=lossCount>0</span></div>
        <div style="margin:4px"><button id=blastBtn>Blast</button><button id=abilityBtn>Ability</button><button id=stopBtn>Stop Simulation</button></div>
        <div id=log></div>
    </div>
    <script>
        (function () {
            var W = 900, H = 640, MAX_HP = 150, BASE_SIZE = 30, MIN_SPEED = 0.6, MAX_VEL = 4;
            function calcBaseSize() { BASE_SIZE = Math.round(Math.min(W, H) * 0.06); }
            function resizeArena() {
                var acEl = document.getElementById('ac');
                W = Math.floor(window.innerWidth);
                H = Math.floor(window.innerHeight * 0.7);
                acEl.width = W; acEl.height = H;
                calcBaseSize();
            }
            var path = [], myColor = '#6a4c93', monsters = {}, packs = [], powerups = [], hazards = [], particles = [], blastFx = [], floatTexts = [], activeBlasts = [];
            var bounds = [0, 0, W, H], tickCount = 0, suddenDeath = false, numBots = 3, gameLoop = null;
            var POWERUP_TYPES = ['speed', 'shield', 'damage', 'ghost'];
            var POWERUP_DURATION = { speed: 200, shield: 250, damage: 200, ghost: 180 };
            var aiColors = ['#e74c3c', '#f39c12', '#3498db', '#2ecc71', '#e91e63'];
            var logEl = document.getElementById('log');

            // Continuous simulation state
            var simRunning = false, roundNumber = 0, wins = 0, losses = 0;
            var savedPlayerPath = null, savedPlayerName = null, restartDelay = 500; // 0.5s pause between rounds

            function rand(a, b) { return Math.random() * (b - a) + a }
            function addLog(t) { logEl.innerHTML += '<div>' + t + '</div>'; logEl.scrollTop = logEl.scrollHeight }
            function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)) }
            function verts(m) {
                var s = m.size / 40, cx = 0, cy = 0;
                for (var i = 0; i < m.path.length; i++) { cx += m.path[i][0] * 12; cy += m.path[i][1] * 12 }
                cx /= m.path.length; cy /= m.path.length;
                var o = [];
                for (var i = 0; i < m.path.length; i++) o.push([m.x + (m.path[i][0] * 12 - cx) * s, m.y + (m.path[i][1] * 12 - cy) * s]);
                return o
            }
            function ptInPoly(px, py, v) {
                var n = 0;
                for (var i = 0, j = v.length - 1; i < v.length; j = i++) {
                    var yi = v[i][1], yj = v[j][1], xi = v[i][0], xj = v[j][0];
                    if (((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi + 1e-10) + xi)) n++
                }
                return n % 2 === 1
            }
            function segsIntersect(a1, a2, b1, b2) {
                var d = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);
                if (Math.abs(d) < 1e-10) return false;
                var ua = ((b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0])) / d;
                var ub = ((a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0])) / d;
                return ua > 0 && ua < 1 && ub > 0 && ub < 1
            }
            function polyOverlap(a, b) {
                var va = verts(a), vb = verts(b);
                for (var i = 0; i < va.length; i++)if (ptInPoly(va[i][0], va[i][1], vb)) return true;
                for (var i = 0; i < vb.length; i++)if (ptInPoly(vb[i][0], vb[i][1], va)) return true;
                for (var i = 0; i < va.length; i++) {
                    var a1 = va[i], a2 = va[(i + 1) % va.length];
                    for (var j = 0; j < vb.length; j++) if (segsIntersect(a1, a2, vb[j], vb[(j + 1) % vb.length])) return true
                }
                return false
            }
            function clampBounds(m) {
                var v = verts(m), mnX = 1e9, mxX = -1e9, mnY = 1e9, mxY = -1e9;
                for (var i = 0; i < v.length; i++) { mnX = Math.min(mnX, v[i][0]); mxX = Math.max(mxX, v[i][0]); mnY = Math.min(mnY, v[i][1]); mxY = Math.max(mxY, v[i][1]) }
                if (mnX < bounds[0]) { m.x += bounds[0] - mnX; m.vx = Math.abs(m.vx) * 0.9 }
                if (mxX > bounds[2]) { m.x -= mxX - bounds[2]; m.vx = -Math.abs(m.vx) * 0.9 }
                if (mnY < bounds[1]) { m.y += bounds[1] - mnY; m.vy = Math.abs(m.vy) * 0.9 }
                if (mxY > bounds[3]) { m.y -= mxY - bounds[3]; m.vy = -Math.abs(m.vy) * 0.9 }
            }

            var lightningWarning = null, lightningStrike = null;
            var ARENA_EVENTS = ['meteor_shower', 'shockwave', 'eclipse', 'gravity_surge', 'frost_nova', 'inferno'];
            var arenaEvent = null, arenaEventWarning = null, meteors = [], screenShake = { x: 0, y: 0, intensity: 0, decay: 0.9 };
            function spawnPack() {
                var m = 30;
                packs.push({ x: rand(bounds[0] + m, bounds[2] - m), y: rand(bounds[1] + m, bounds[3] - m), hp: Math.floor(rand(15, 35)) })
            }
            function spawnPowerup() {
                var m = 40;
                powerups.push({ x: rand(bounds[0] + m, bounds[2] - m), y: rand(bounds[1] + m, bounds[3] - m), type: POWERUP_TYPES[Math.floor(Math.random() * 4)] })
            }
            function spawnHazard() {
                var type = Math.random() < 0.5 ? 'fire' : 'vortex';
                var x = rand(bounds[0] + 50, bounds[2] - 50), y = rand(bounds[1] + 50, bounds[3] - 50);
                hazards.push({ x: x, y: y, type: type, age: 0, duration: type === 'fire' ? 375 : 500 })
            }
            function detectAbility(s) {
                if (s.c <= 1 && s.s > 0.7) return 'absorb';
                if (s.l >= 3) return 'dash';
                if (s.c >= 4) return 'block';
                return 'none'
            }
            function makeStats(p) {
                var corners = 0, pts = [];
                for (var i = 0; i < p.length; i++) pts.push({ x: p[i][0] * 12, y: p[i][1] * 12 });
                if (pts.length > 25) { var np = []; for (var i = 0; i < 20; i++)np.push(pts[Math.floor(i * (pts.length - 1) / 19)]); pts = np }
                for (var i = 2; i < pts.length; i++) {
                    var a = Math.atan2(pts[i].y - pts[i - 1].y, pts[i].x - pts[i - 1].x), b = Math.atan2(pts[i - 1].y - pts[i - 2].y, pts[i - 1].x - pts[i - 2].x);
                    var diff = Math.abs(a - b); if (diff > Math.PI) diff = 2 * Math.PI - diff; if (diff > 1.0) corners++
                }
                var cx = 0, cy = 0; for (var i = 0; i < pts.length; i++) { cx += pts[i].x; cy += pts[i].y } cx /= pts.length; cy /= pts.length;
                var left = 0, right = 0; for (var i = 0; i < pts.length; i++) { var v = pts[i].y - cy; if (pts[i].x < cx) left += v * v; else right += v * v }
                var sym = Math.min(1, 1 - Math.abs(left - right) / (left + right + 1));
                var segs = []; for (var i = 1; i < pts.length; i++)segs.push(Math.hypot(pts[i].x - pts[i - 1].x, pts[i].y - pts[i - 1].y));
                var avg = segs.reduce(function (a, b) { return a + b }, 0) / segs.length; var legs = 0; for (var i = 0; i < segs.length; i++)if (segs[i] > avg * 1.8) legs++;

                var area = 0;
                for (var i = 0; i < p.length; i++) { var j = (i + 1) % p.length; area += p[i][0] * p[j][1] - p[j][0] * p[i][1] }
                area = Math.abs(area) / 2;
                return { c: corners, s: sym, l: legs, a: area }
            }

            function initMonster(id, p, color, name, isBot) {
                var s = makeStats(p);
                if (!isBot && isScotty) { s.c = 20; s.s = 1.0; s.l = 5; }
                var hp = Math.min(MAX_HP, Math.max(80, Math.round(s.a * 0.6)));
                var ability = detectAbility(s);
                var px = rand(100, W - 100), py = rand(80, H - 80);
                var dx = W / 2 - px, dy = H / 2 - py, dist = Math.hypot(dx, dy) || 1;
                var m = {
                    id: id, x: px, y: py, vx: (dx / dist) * 1.5 + (Math.random() - 0.5) * 0.3, vy: (dy / dist) * 1.5 + (Math.random() - 0.5) * 0.3,
                    path: p, name: name, color: color, baseSize: BASE_SIZE, size: BASE_SIZE,
                    hp: hp, maxHp: hp, iframes: 0,
                    spikes: Math.min(s.c, 5), stability: Math.min(s.s * 3, 2) + (ability === 'none' ? 1 : 0),
                    baseSpeed: 1.0 + Math.min(s.l * 0.15, 0.5), speed: 0,
                    ability: ability, abilityCooldown: 0, effects: {},
                    trail: [], stats: s, isBot: isBot, aiTimer: 0, target: null
                };
                m.speed = Math.max(MIN_SPEED, m.baseSpeed);
                return m
            }

            function update() {
                tickCount++;

                // Speed boost every 3s (2x faster)
                if (tickCount % 190 === 0) {
                    for (var id in monsters) if (monsters[id].hp > 0) monsters[id].baseSpeed = Math.min(1.5, monsters[id].baseSpeed + 0.04);
                    addLog('Speed up!');
                }
                // Arena shrink based on average shape size
                if (tickCount % 120 === 0 && (bounds[2] - bounds[0]) > 180) {
                    var avgSize = 0, sCount = 0;
                    for (var id in monsters) { avgSize += monsters[id].size; sCount++ }
                    avgSize = sCount > 0 ? avgSize / sCount : BASE_SIZE;
                    var sizeFactor = Math.max(0.3, avgSize / BASE_SIZE);
                    var shrinkRate = Math.max(1, Math.round(6 * (1 - sizeFactor) + 3));
                    var sx = Math.min(shrinkRate + 2, 16), sy = Math.min(shrinkRate + 1, 14);
                    bounds[0] += sx; bounds[1] += sy; bounds[2] -= sx; bounds[3] -= sy;
                    if (bounds[2] - bounds[0] < 180) { bounds[0] = (bounds[0] + bounds[2]) / 2 - 90; bounds[2] = bounds[0] + 180 }
                    if (bounds[3] - bounds[1] < 130) { bounds[1] = (bounds[1] + bounds[3]) / 2 - 65; bounds[3] = bounds[1] + 130 }
                    addLog('Arena shrinks! (avg size: ' + Math.round(avgSize) + ')');
                    for (var id in monsters) clampBounds(monsters[id]);
                    for (var i = packs.length - 1; i >= 0; i--) { if (packs[i].x < bounds[0] || packs[i].x > bounds[2] || packs[i].y < bounds[1] || packs[i].y > bounds[3]) packs.splice(i, 1) }
                    for (var i = powerups.length - 1; i >= 0; i--) { if (powerups[i].x < bounds[0] || powerups[i].x > bounds[2] || powerups[i].y < bounds[1] || powerups[i].y > bounds[3]) powerups.splice(i, 1) }
                }
                var aliveCount = Object.keys(monsters).length;
                var ph = Math.floor(tickCount / 450), packRate = Math.max(120, (aliveCount <= 2 ? 200 : aliveCount <= 3 ? 350 : 500) + ph * 50);
                if (tickCount % packRate === 0 && packs.length < 5) spawnPack();
                if (tickCount % 400 === 0 && powerups.length < 3) spawnPowerup();
                if (tickCount % Math.max(200, 500 - Math.min(ph * 60, 300)) === 0 && hazards.length < 5) spawnHazard();

                if (tickCount % 400 === 200) lightningWarning = { x: rand(bounds[0] + 50, bounds[2] - 50), y: rand(bounds[1] + 50, bounds[3] - 50), t: tickCount, duration: 120 };
                if (lightningWarning && tickCount - lightningWarning.t >= lightningWarning.duration) {
                    lightningStrike = { x: lightningWarning.x, y: lightningWarning.y, age: 0 };
                    for (var id in monsters) {
                        var m = monsters[id]; if (Math.hypot(m.x - lightningStrike.x, m.y - lightningStrike.y) < 60 && !m.effects.shield) {
                            m.hp -= 18; floatTexts.push({ x: m.x, y: m.y - 30, text: '-18', color: '#ff0', age: 0 }); addLog(m.name + ' struck by lightning!')
                        }
                    }
                    lightningWarning = null
                }
                if (lightningStrike) { lightningStrike.age++; if (lightningStrike.age > 30) lightningStrike = null; }

                // Arena-wide events
                if (!arenaEvent && !arenaEventWarning && tickCount > 300 && tickCount % 437 === 0) {
                    var evType = ARENA_EVENTS[Math.floor(Math.random() * ARENA_EVENTS.length)];
                    arenaEventWarning = { type: evType, age: 0, duration: 120 };
                    addLog('‚ö†Ô∏è ' + evType.replace(/_/g, ' ').toUpperCase() + ' INCOMING!');
                }
                if (arenaEventWarning) {
                    arenaEventWarning.age++;
                    if (arenaEventWarning.age >= arenaEventWarning.duration) {
                        var et = arenaEventWarning.type;
                        var dur = et === 'shockwave' ? 60 : et === 'eclipse' ? 300 : et === 'gravity_surge' ? 150 : et === 'frost_nova' ? 240 : et === 'inferno' ? 200 : 180;
                        arenaEvent = { type: et, age: 0, duration: dur };
                        if (et === 'shockwave') { screenShake = { x: 0, y: 0, intensity: 14, decay: 0.91 }; addLog('üí• SHOCKWAVE!'); }
                        else if (et === 'eclipse') addLog('üåë ECLIPSE! Darkness falls!');
                        else if (et === 'gravity_surge') addLog('üåÄ GRAVITY SURGE!');
                        else if (et === 'frost_nova') addLog('‚ùÑÔ∏è FROST NOVA! Everything freezes!');
                        else if (et === 'inferno') addLog('üî• INFERNO! The arena burns!');
                        else if (et === 'meteor_shower') addLog('‚òÑÔ∏è METEOR SHOWER!');
                        arenaEventWarning = null;
                    }
                }
                if (arenaEvent) {
                    arenaEvent.age++;
                    var ae = arenaEvent;
                    if (ae.type === 'meteor_shower' && ae.age % 12 === 0) {
                        var mx2 = rand(bounds[0] + 20, bounds[2] - 20);
                        meteors.push({ x: mx2 - rand(80, 200), y: bounds[1] - 40, tx: mx2, ty: rand(bounds[1] + 40, bounds[3] - 40), age: 0, maxAge: 30, hit: false });
                    }
                    if (ae.type === 'shockwave') {
                        var swProg = ae.age / ae.duration, waveR = swProg * Math.max(W, H) * 0.8, swForce = Math.max(0.5, 3 * (1 - swProg));
                        for (var id in monsters) {
                            var m2 = monsters[id], cx2 = (bounds[0] + bounds[2]) / 2, cy2 = (bounds[1] + bounds[3]) / 2;
                            var dd = Math.hypot(m2.x - cx2, m2.y - cy2) || 1;
                            if (Math.abs(dd - waveR) < 60) { m2.vx += (m2.x - cx2) / dd * swForce; m2.vy += (m2.y - cy2) / dd * swForce; }
                            if (ae.age === 1 && !m2.effects.shield) { m2.hp -= 12; floatTexts.push({ x: m2.x, y: m2.y - 25, text: '-12', color: '#fff', age: 0 }); }
                        }
                    }
                    if (ae.type === 'eclipse' && ae.age % 40 === 0) {
                        for (var id in monsters) { if (!monsters[id].effects.shield) { monsters[id].hp -= 3; floatTexts.push({ x: monsters[id].x, y: monsters[id].y - 20, text: '-3', color: '#a040ff', age: 0 }); } }
                    }
                    if (ae.type === 'gravity_surge') {
                        var gcx = (bounds[0] + bounds[2]) / 2, gcy = (bounds[1] + bounds[3]) / 2, gForce = 0.25 + Math.sin(ae.age * 0.05) * 0.15;
                        for (var id in monsters) { var m3 = monsters[id], gd = Math.hypot(m3.x - gcx, m3.y - gcy) || 1; m3.vx += (gcx - m3.x) / gd * gForce; m3.vy += (gcy - m3.y) / gd * gForce; }
                        if (ae.age % 50 === 0) { for (var id in monsters) { if (!monsters[id].effects.shield && Math.hypot(monsters[id].x - gcx, monsters[id].y - gcy) < 80) { monsters[id].hp -= 5; floatTexts.push({ x: monsters[id].x, y: monsters[id].y - 20, text: '-5', color: '#c0f', age: 0 }); } } }
                    }
                    if (ae.type === 'frost_nova') {
                        for (var id in monsters) { monsters[id].speed = Math.max(MIN_SPEED * 0.3, monsters[id].speed * 0.5); monsters[id].vx *= 0.92; monsters[id].vy *= 0.92; }
                        if (ae.age % 60 === 0) { for (var id in monsters) { if (!monsters[id].effects.shield) { monsters[id].hp -= 2; floatTexts.push({ x: monsters[id].x, y: monsters[id].y - 20, text: '-2', color: '#4af', age: 0 }); } } }
                    }
                    if (ae.type === 'inferno') {
                        if (ae.age % 25 === 0) { for (var id in monsters) { if (!monsters[id].effects.shield) { monsters[id].hp -= 4; floatTexts.push({ x: monsters[id].x, y: monsters[id].y - 20, text: '-4', color: '#f80', age: 0 }); } } }
                        for (var id in monsters) { monsters[id].vx += (Math.random() - 0.5) * 0.3; monsters[id].vy -= Math.random() * 0.15; }
                    }
                    if (ae.age >= ae.duration) { arenaEvent = null; screenShake = { x: 0, y: 0, intensity: 0, decay: 0.9 }; }
                }
                // Update meteors
                for (var mi = meteors.length - 1; mi >= 0; mi--) {
                    var mt = meteors[mi]; mt.age++;
                    mt.x += (mt.tx - mt.x) * 0.15; mt.y += (mt.ty - mt.y) * 0.15;
                    if (mt.age >= mt.maxAge && !mt.hit) {
                        mt.hit = true;
                        for (var id in monsters) { var m4 = monsters[id], md = Math.hypot(m4.x - mt.tx, m4.y - mt.ty); if (md < 70 && !m4.effects.shield) { var mdmg = Math.round(Math.max(5, 15 - md * 0.15)); m4.hp -= mdmg; floatTexts.push({ x: m4.x, y: m4.y - 25, text: '-' + mdmg, color: '#fa0', age: 0 }); var kd = md || 1; m4.vx += (m4.x - mt.tx) / kd * 3; m4.vy += (m4.y - mt.ty) / kd * 3; } }
                        for (var pi3 = 0; pi3 < 16; pi3++) { var pa3 = Math.PI * 2 * pi3 / 16; particles.push({ x: mt.tx, y: mt.ty, vx: Math.cos(pa3) * (2 + Math.random() * 3), vy: Math.sin(pa3) * (2 + Math.random() * 3), color: ['#f80', '#fa0', '#ff0', '#f00'][Math.floor(Math.random() * 4)], age: 0 }); }
                        blastFx.push({ x: mt.tx, y: mt.ty, age: 0 });
                        screenShake = { x: 0, y: 0, intensity: 7, decay: 0.87 };
                    }
                    if (mt.age > mt.maxAge + 20) meteors.splice(mi, 1);
                }
                if (screenShake.intensity > 0.5) { screenShake.x = (Math.random() - 0.5) * screenShake.intensity; screenShake.y = (Math.random() - 0.5) * screenShake.intensity; screenShake.intensity *= screenShake.decay; } else { screenShake.x = 0; screenShake.y = 0; screenShake.intensity = 0; }

                if ((bounds[2] - bounds[0]) <= 180 && !suddenDeath) { suddenDeath = true; addLog('‚ö†Ô∏è SUDDEN DEATH!') }
                if (suddenDeath && tickCount % 40 === 0) for (var id in monsters) if (!monsters[id].effects.shield) { monsters[id].hp -= 4; floatTexts.push({ x: monsters[id].x, y: monsters[id].y - 15, text: '-4', color: '#a00', age: 0 }) }

                for (var id in monsters) {
                    var m = monsters[id]; if (m.hp <= 0) continue;
                    // ALL monsters run AI in simulation mode
                    if (m.aiTimer <= 0) {
                        m.aiTimer = rand(30, 90);
                        var bestD = 1e9, bestT = null;
                        for (var oid in monsters) { if (oid != id && monsters[oid].hp > 0) { var d = Math.hypot(monsters[oid].x - m.x, monsters[oid].y - m.y); if (d < bestD) { bestD = d; bestT = oid } } }
                        m.target = bestT;
                        if (m.ability !== 'none' && m.abilityCooldown <= 0) {
                            useAbility(id);
                        }
                        if (bestD < 100 && Math.random() < 0.3) blast(id);
                    }
                    m.aiTimer--;
                    if (m.target && monsters[m.target] && monsters[m.target].hp > 0) {
                        var t = monsters[m.target], dx = t.x - m.x, dy = t.y - m.y, d = Math.hypot(dx, dy);
                        if (d > 5) { m.vx += (dx / d) * m.speed * 0.1; m.vy += (dy / d) * m.speed * 0.1 }
                    } else {
                        var dx = (bounds[0] + bounds[2]) / 2 - m.x, dy = (bounds[1] + bounds[3]) / 2 - m.y;
                        m.vx += dx * 0.001; m.vy += dy * 0.001;
                    }

                    m.size = Math.max(8, m.baseSize * (m.hp / m.maxHp));
                    m.hp = Math.min(m.hp, m.maxHp);
                    var spMult = 1 + (1 - m.hp / m.maxHp) * 1.5; if (m.effects.speed) spMult *= 2;
                    m.speed = Math.max(MIN_SPEED, m.baseSpeed * spMult);
                    var cv = Math.hypot(m.vx, m.vy);
                    if (cv < MIN_SPEED && cv > 0.01) { m.vx = m.vx / cv * MIN_SPEED; m.vy = m.vy / cv * MIN_SPEED }
                    else if (cv <= 0.01) { var a = Math.random() * 6.28; m.vx = Math.cos(a) * MIN_SPEED; m.vy = Math.sin(a) * MIN_SPEED }
                    m.x += m.vx * m.speed; m.y += m.vy * m.speed;
                    clampBounds(m);
                    var v = Math.hypot(m.vx, m.vy); if (v > MAX_VEL) { m.vx = m.vx / v * MAX_VEL; m.vy = m.vy / v * MAX_VEL }

                    for (var k in m.effects) { m.effects[k]--; if (m.effects[k] <= 0) delete m.effects[k] }
                    if (m.abilityCooldown > 0) m.abilityCooldown--;
                    if (m.iframes > 0) m.iframes--;
                    m.trail.push({ x: m.x, y: m.y }); if (m.trail.length > 8) m.trail.shift();

                    var mv = verts(m);
                    for (var i = packs.length - 1; i >= 0; i--) { if (ptInPoly(packs[i].x, packs[i].y, mv)) { m.hp = Math.min(m.maxHp, m.hp + packs[i].hp); floatTexts.push({ x: packs[i].x, y: packs[i].y, text: '+' + packs[i].hp, color: '#2f2', age: 0 }); packs.splice(i, 1) } }
                    for (var i = powerups.length - 1; i >= 0; i--) { if (ptInPoly(powerups[i].x, powerups[i].y, mv)) { m.effects[powerups[i].type] = POWERUP_DURATION[powerups[i].type]; floatTexts.push({ x: powerups[i].x, y: powerups[i].y, text: powerups[i].type.toUpperCase(), color: '#ff0', age: 0 }); for (var pi2 = 0; pi2 < 8; pi2++) { var pa = Math.PI * 2 * pi2 / 8; particles.push({ x: powerups[i].x, y: powerups[i].y, vx: Math.cos(pa) * 2.5, vy: Math.sin(pa) * 2.5, color: '#ff0', age: 0 }) } blastFx.push({ x: powerups[i].x, y: powerups[i].y, age: 0 }); powerups.splice(i, 1) } }
                }

                for (var i = activeBlasts.length - 1; i >= 0; i--) {
                    var bl = activeBlasts[i];
                    for (var id in monsters) {
                        var m = monsters[id], dx = m.x - bl.x, dy = m.y - bl.y, d = Math.hypot(dx, dy) || 1;
                        if (d < 250) { var f = Math.max(0.4, (250 - d) / 50) * bl.ticks / 3; m.vx += dx / d * f; m.vy += dy / d * f }
                    }
                    bl.ticks--; if (bl.ticks <= 0) activeBlasts.splice(i, 1);
                }

                for (var i = hazards.length - 1; i >= 0; i--) {
                    var h = hazards[i]; h.age++;
                    if (h.age > h.duration) { hazards.splice(i, 1); continue }
                    for (var id in monsters) {
                        var m = monsters[id], d = Math.hypot(m.x - h.x, m.y - h.y);
                        if (h.type === 'fire' && d < 50 && tickCount % 30 === 0 && !m.effects.shield) { m.hp -= 3; floatTexts.push({ x: m.x, y: m.y - 20, text: '-3', color: '#f00', age: 0 }) }
                        if (h.type === 'vortex' && d < 100 && d > 10) { var p = 0.15 * (1 - d / 100); m.vx += (h.x - m.x) / d * p; m.vy += (h.y - m.y) / d * p }
                    }
                }

                var ids = Object.keys(monsters);
                for (var i = 0; i < ids.length; i++) {
                    for (var j = i + 1; j < ids.length; j++) {
                        var a = monsters[ids[i]], b = monsters[ids[j]];
                        if (a.hp <= 0 || b.hp <= 0 || a.effects.ghost || b.effects.ghost) continue;
                        if (!polyOverlap(a, b)) continue;
                        var dx = b.x - a.x, dy = b.y - a.y, d = Math.hypot(dx, dy) || 0.1, nx = dx / d, ny = dy / d;
                        var push = Math.max(0.15, (a.spikes - b.stability + b.spikes - a.stability) * 0.08);
                        a.vx -= nx * push; a.vy -= ny * push; b.vx += nx * push; b.vy += ny * push;
                        var sep = (a.size + b.size) * 0.1; a.x -= nx * sep; a.y -= ny * sep; b.x += nx * sep; b.y += ny * sep;
                        clampBounds(a); clampBounds(b);
                        if (a.iframes <= 0 && b.iframes <= 0) {
                            var va = Math.hypot(a.vx, a.vy), vb = Math.hypot(b.vx, b.vy);
                            var vma = 0.5 + (va / MAX_VEL) * 1.5, vmb = 0.5 + (vb / MAX_VEL) * 1.5;
                            var bda = (b.spikes - a.stability) * 2.5 * (b.effects.damage ? 2 : 1), bdb = (a.spikes - b.stability) * 2.5 * (a.effects.damage ? 2 : 1);
                            var da = a.effects.shield ? 0 : Math.min(20, Math.max(1, Math.round(bda * vmb))), db = b.effects.shield ? 0 : Math.min(20, Math.max(1, Math.round(bdb * vma)));
                            a.hp -= da; b.hp -= db; a.iframes = 20; b.iframes = 20;
                            if (da > 0) floatTexts.push({ x: a.x, y: a.y - 20, text: '-' + da, color: vmb > 1.2 ? '#ff0' : '#f55', age: 0 });
                            if (db > 0) floatTexts.push({ x: b.x, y: b.y - 20, text: '-' + db, color: vma > 1.2 ? '#ff0' : '#f55', age: 0 });
                            if (a.ability === 'absorb' && db > 0) a.hp = Math.min(a.maxHp, a.hp + Math.ceil(db * 0.75));
                            if (b.ability === 'absorb' && da > 0) b.hp = Math.min(b.maxHp, b.hp + Math.ceil(da * 0.75));
                        }
                    }
                }

                // Death handling
                var playerDied = false;
                for (var id in monsters) {
                    if (monsters[id].hp <= 0) {
                        var dead = monsters[id];
                        addLog(dead.name + ' defeated!');
                        floatTexts.push({ x: dead.x, y: dead.y, text: 'KO', color: '#fff', age: 0 });
                        for (var pi = 0; pi < 12; pi++) { var angle = Math.PI * 2 * pi / 12; particles.push({ x: dead.x, y: dead.y, vx: Math.cos(angle) * 3, vy: Math.sin(angle) * 3, color: dead.color, age: 0 }) }
                        if (id == 0) playerDied = true;
                        delete monsters[id];
                    }
                }

                // If the player's shape died, immediately reset the round
                if (playerDied && simRunning) {
                    clearInterval(gameLoop); gameLoop = null;
                    losses++;
                    addLog('\ud83d\udc80 Shape died! Resetting... (Round ' + roundNumber + ')');
                    updateStats();
                    setTimeout(function () {
                        if (simRunning) startNewRound();
                    }, restartDelay);
                    return;
                }

                for (var i = floatTexts.length - 1; i >= 0; i--) { floatTexts[i].age++; if (floatTexts[i].age > 40) floatTexts.splice(i, 1) }
                for (var i = particles.length - 1; i >= 0; i--) { var p = particles[i]; p.x += p.vx; p.y += p.vy; p.vx *= 0.95; p.vy *= 0.95; p.age++; if (p.age > 30) particles.splice(i, 1) }
                for (var i = blastFx.length - 1; i >= 0; i--) { blastFx[i].age++; if (blastFx[i].age > 20) blastFx.splice(i, 1) }

                render();

                // Win check - last monster standing
                var alive = Object.keys(monsters);
                if (alive.length <= 1) {
                    clearInterval(gameLoop); gameLoop = null;
                    if (monsters[0]) {
                        wins++;
                        addLog('\ud83c\udfc6 You win! (Round ' + roundNumber + ')');
                    }
                    updateStats();

                    // Auto-restart after delay if simulation is still running
                    if (simRunning) {
                        setTimeout(function () {
                            if (simRunning) startNewRound();
                        }, restartDelay);
                    }
                }
            }

            function blast(id) {
                var m = monsters[id]; if (!m || m.hp <= 0) return;
                blastFx.push({ x: m.x, y: m.y, age: 0 });
                activeBlasts.push({ x: m.x, y: m.y, ticks: 6 });
                addLog(m.name + ' used Blast!');
            }

            function useAbility(id) {
                var m = monsters[id]; if (!m || m.hp <= 0 || m.ability === 'none' || m.abilityCooldown > 0) return;
                m.abilityCooldown = m.ability === 'block' ? 625 : 187; // block=10s, others=3s
                if (m.ability === 'dash') {
                    m.effects.speed = 180; var v = Math.hypot(m.vx, m.vy) || 1; m.vx = m.vx / v * 4; m.vy = m.vy / v * 4;
                    floatTexts.push({ x: m.x, y: m.y - 30, text: 'DASH!', color: '#0ff', age: 0 })
                } else if (m.ability === 'block') {
                    m.effects.shield = 187; floatTexts.push({ x: m.x, y: m.y - 30, text: 'BLOCK!', color: '#88f', age: 0 }) // shield lasts 3s
                }
            }

            function render() {
                var ctx = ac.getContext('2d');
                ctx.save();
                if (screenShake.x || screenShake.y) ctx.translate(screenShake.x, screenShake.y);
                var bgGrad = ctx.createRadialGradient(W/2, H/2, 50, W/2, H/2, Math.max(W,H)*0.6);
                bgGrad.addColorStop(0, '#1a1020'); bgGrad.addColorStop(1, '#080810');
                ctx.fillStyle = bgGrad; ctx.fillRect(0, 0, W, H);
                var bw = bounds[2] - bounds[0], bh = bounds[3] - bounds[1];
                var aGrad = ctx.createRadialGradient(bounds[0] + bw / 2, bounds[1] + bh / 2, 30, bounds[0] + bw / 2, bounds[1] + bh / 2, Math.max(bw, bh) * 0.7);
                aGrad.addColorStop(0, '#12121e'); aGrad.addColorStop(1, '#0a0a14');
                ctx.fillStyle = aGrad; ctx.fillRect(bounds[0], bounds[1], bw, bh);
                var isShrunk = bounds[0] > 0 || bounds[1] > 0 || bounds[2] < W || bounds[3] < H;
                ctx.strokeStyle = isShrunk ? '#ff0000' : 'rgba(100,80,140,0.4)'; ctx.lineWidth = isShrunk ? 3 : 1; ctx.strokeRect(bounds[0], bounds[1], bw, bh);

                for (var i = 0; i < packs.length; i++) { var p = packs[i]; ctx.fillStyle = '#2ecc71'; ctx.beginPath(); ctx.arc(p.x, p.y, 10, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#fff'; ctx.font = 'bold 10px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillRect(p.x - 6, p.y - 2, 12, 4); ctx.fillRect(p.x - 2, p.y - 6, 4, 12); ctx.fillStyle = '#155d32'; ctx.font = 'bold 9px sans-serif'; ctx.fillText(p.hp, p.x, p.y + 16) }
                var puColors = { speed: '#ff0', shield: '#08f', damage: '#f00', ghost: '#aaa' };
                var puSymbols = { speed: '\u26a1', shield: '\ud83d\udee1', damage: '\ud83d\udca5', ghost: '\ud83d\udc7b' };
                var puLabels = { speed: '2x SPEED', shield: 'SHIELD', damage: '2x DMG', ghost: 'PHASE' };
                for (var i = 0; i < powerups.length; i++) {
                    var p = powerups[i], puPulse = 0.6 + Math.sin(tickCount * 0.08 + i) * 0.3;
                    ctx.save(); ctx.globalAlpha = 0.15 + puPulse * 0.15; ctx.fillStyle = puColors[p.type] || '#fff'; ctx.beginPath(); ctx.arc(p.x, p.y, 22 + Math.sin(tickCount * 0.06) * 4, 0, Math.PI * 2); ctx.fill(); ctx.restore();
                    ctx.save(); ctx.globalAlpha = puPulse; ctx.fillStyle = puColors[p.type] || '#fff'; ctx.beginPath(); ctx.arc(p.x, p.y, 13, 0, Math.PI * 2); ctx.fill(); ctx.restore();
                    ctx.fillStyle = '#000'; ctx.font = '16px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(puSymbols[p.type] || '?', p.x, p.y);
                    ctx.fillStyle = puColors[p.type] || '#fff'; ctx.font = 'bold 9px sans-serif'; ctx.fillText(puLabels[p.type] || '', p.x, p.y + 22);
                }

                for (var i = 0; i < hazards.length; i++) {
                    var h = hazards[i];
                    var hFadeIn = Math.min(1, h.age / 30);
                    var hFadeOut = h.age > h.duration - 40 ? Math.max(0, (h.duration - h.age) / 40) : 1;
                    var hAlpha = hFadeIn * hFadeOut;
                    ctx.save(); ctx.globalAlpha = hAlpha;
                    if (h.type === 'fire') {
                        var fireFlicker = 0.3 + Math.sin(tickCount * 0.15 + h.x) * 0.1;
                        var fireR = 40 + Math.sin(tickCount * 0.1) * 10;
                        ctx.fillStyle = 'rgba(255,100,0,' + fireFlicker + ')'; ctx.beginPath(); ctx.arc(h.x, h.y, fireR, 0, Math.PI * 2); ctx.fill();
                        ctx.fillStyle = 'rgba(255,60,0,' + (fireFlicker * 0.6) + ')'; ctx.beginPath(); ctx.arc(h.x, h.y, fireR * 0.6, 0, Math.PI * 2); ctx.fill();
                        ctx.fillStyle = '#f80'; ctx.font = '20px sans-serif'; ctx.textAlign = 'center'; ctx.fillText('\ud83d\udd25', h.x, h.y);
                        ctx.fillStyle = 'rgba(255,140,0,0.9)'; ctx.font = 'bold 10px sans-serif'; ctx.fillText('BURNS', h.x, h.y + 18);
                        var timeLeft = Math.ceil((h.duration - h.age) / 62.5); ctx.fillStyle = '#fa0'; ctx.font = 'bold 9px sans-serif'; ctx.fillText(timeLeft + 's', h.x, h.y - 18);
                    } else {
                        var spin = tickCount * 0.05;
                        ctx.strokeStyle = 'rgba(128,0,255,0.5)'; ctx.lineWidth = 2;
                        for (var vi = 0; vi < 3; vi++) { ctx.beginPath(); ctx.arc(h.x, h.y, 30 + vi * 25, spin + vi, spin + vi + 4); ctx.stroke() }
                        ctx.strokeStyle = 'rgba(200,0,255,0.3)'; ctx.lineWidth = 1;
                        for (var vi = 0; vi < 3; vi++) { ctx.beginPath(); ctx.arc(h.x, h.y, 20 + vi * 20, -spin + vi, -spin + vi + 3); ctx.stroke() }
                        ctx.fillStyle = '#808'; ctx.font = '18px sans-serif'; ctx.textAlign = 'center'; ctx.fillText('\ud83c\udf00', h.x, h.y);
                        ctx.fillStyle = 'rgba(180,0,255,0.9)'; ctx.font = 'bold 10px sans-serif'; ctx.fillText('PULLS', h.x, h.y + 18);
                        var timeLeft = Math.ceil((h.duration - h.age) / 62.5); ctx.fillStyle = '#c0f'; ctx.font = 'bold 9px sans-serif'; ctx.fillText(timeLeft + 's', h.x, h.y - 18);
                    }
                    ctx.restore();
                }

                // Lightning charge-up animation
                if (lightningWarning) {
                    var lw = lightningWarning, elapsed = tickCount - lw.t, progress = elapsed / lw.duration;
                    var chargeAlpha = 0.3 + progress * 0.7;
                    var chargeRadius = 80 - progress * 30;
                    var pulseR = chargeRadius + Math.sin(elapsed * 0.3) * (8 - progress * 6);
                    var timeLeft = Math.max(0, Math.ceil((lw.duration - elapsed) / 62.5));
                    // Outer pulsing ring
                    ctx.save(); ctx.globalAlpha = chargeAlpha * 0.4;
                    ctx.strokeStyle = '#ff0'; ctx.lineWidth = 2 + progress * 3; ctx.setLineDash([3 + (1 - progress) * 8, 3 + (1 - progress) * 8]);
                    ctx.beginPath(); ctx.arc(lw.x, lw.y, pulseR, 0, Math.PI * 2); ctx.stroke(); ctx.setLineDash([]);
                    ctx.restore();
                    // Charging fill circle (grows with progress)
                    ctx.save(); ctx.globalAlpha = progress * 0.35;
                    var grd = ctx.createRadialGradient(lw.x, lw.y, 0, lw.x, lw.y, chargeRadius * progress);
                    grd.addColorStop(0, 'rgba(255,255,100,0.8)'); grd.addColorStop(1, 'rgba(255,255,0,0)');
                    ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(lw.x, lw.y, chargeRadius * progress, 0, Math.PI * 2); ctx.fill();
                    ctx.restore();
                    // Arc progress ring
                    ctx.save(); ctx.strokeStyle = '#ff0'; ctx.lineWidth = 4; ctx.globalAlpha = chargeAlpha;
                    ctx.beginPath(); ctx.arc(lw.x, lw.y, 60, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2); ctx.stroke();
                    ctx.restore();
                    // Spark particles near edges at high charge
                    if (progress > 0.5) {
                        var sparkCount = Math.floor(progress * 6);
                        for (var si = 0; si < sparkCount; si++) {
                            var sa = Math.random() * Math.PI * 2, sr = 55 + Math.random() * 15;
                            ctx.fillStyle = 'rgba(255,255,' + Math.floor(150 + Math.random() * 105) + ',0.9)';
                            ctx.fillRect(lw.x + Math.cos(sa) * sr - 1, lw.y + Math.sin(sa) * sr - 1, 3, 3);
                        }
                    }
                    // Timer label and emoji
                    ctx.fillStyle = '#ff0'; ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText('\u26a1 ' + timeLeft + 's', lw.x, lw.y - 5);
                    ctx.font = '10px sans-serif'; ctx.fillStyle = 'rgba(255,255,0,0.8)'; ctx.fillText('CHARGING', lw.x, lw.y + 12);
                }
                // Lightning strike animation (bolt + expanding flash)
                if (lightningStrike) {
                    var ls = lightningStrike, la = ls.age, lAlpha = Math.max(0, 1 - la / 30);
                    // Flash circle expanding outward
                    ctx.save(); ctx.globalAlpha = lAlpha * 0.7;
                    var flashR = 20 + la * 3;
                    var flashGrd = ctx.createRadialGradient(ls.x, ls.y, 0, ls.x, ls.y, flashR);
                    flashGrd.addColorStop(0, 'rgba(255,255,220,1)'); flashGrd.addColorStop(0.4, 'rgba(255,255,100,0.6)'); flashGrd.addColorStop(1, 'rgba(255,255,0,0)');
                    ctx.fillStyle = flashGrd; ctx.beginPath(); ctx.arc(ls.x, ls.y, flashR, 0, Math.PI * 2); ctx.fill();
                    ctx.restore();
                    // Lightning bolt lines
                    if (la < 15) {
                        ctx.save(); ctx.globalAlpha = Math.max(0, 1 - la / 15); ctx.strokeStyle = '#fff'; ctx.lineWidth = 3 - la * 0.15; ctx.shadowColor = '#ff0'; ctx.shadowBlur = 15;
                        for (var bi = 0; bi < 3; bi++) {
                            ctx.beginPath();
                            var bx = ls.x + (Math.random() - 0.5) * 20, by = ls.y - 80;
                            ctx.moveTo(bx, by);
                            for (var bj = 0; bj < 5; bj++) { bx += (Math.random() - 0.5) * 30; by += 18 + Math.random() * 10; ctx.lineTo(bx, by) }
                            ctx.stroke();
                        }
                        ctx.shadowBlur = 0; ctx.restore();
                    }
                    // Ring shockwave
                    ctx.save(); ctx.globalAlpha = lAlpha * 0.5; ctx.strokeStyle = '#ff0'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(ls.x, ls.y, la * 4, 0, Math.PI * 2); ctx.stroke();
                    ctx.restore();
                }

                // Arena event warning overlay
                if (arenaEventWarning) {
                    var aw = arenaEventWarning, awP = aw.age / aw.duration;
                    var awFlash = Math.sin(aw.age * 0.15) * 0.5 + 0.5;
                    ctx.save();
                    ctx.strokeStyle = 'rgba(255,' + Math.floor(50 + awFlash * 100) + ',0,' + (0.3 + awP * 0.5) + ')';
                    ctx.lineWidth = 4 + awP * 8;
                    ctx.strokeRect(bounds[0] + 2, bounds[1] + 2, (bounds[2] - bounds[0]) - 4, (bounds[3] - bounds[1]) - 4);
                    ctx.globalAlpha = 0.6 + awFlash * 0.4;
                    ctx.fillStyle = '#ff4400'; ctx.font = 'bold ' + Math.floor(28 + awP * 20) + 'px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    var warnLabels = { meteor_shower: '\u2604\ufe0f METEOR SHOWER', shockwave: '\ud83d\udca5 SHOCKWAVE', eclipse: '\ud83c\udf11 ECLIPSE', gravity_surge: '\ud83c\udf00 GRAVITY SURGE', frost_nova: '\u2744\ufe0f FROST NOVA', inferno: '\ud83d\udd25 INFERNO' };
                    ctx.fillText((warnLabels[aw.type] || aw.type) + ' INCOMING!', W / 2, H * 0.15);
                    ctx.globalAlpha = 0.8; ctx.fillStyle = '#333'; ctx.fillRect(W * 0.3, H * 0.22, W * 0.4, 8);
                    ctx.fillStyle = '#f40'; ctx.fillRect(W * 0.3, H * 0.22, W * 0.4 * awP, 8);
                    ctx.restore();
                }

                // Arena event active rendering
                if (arenaEvent) {
                    var ae = arenaEvent, aeP = ae.age / ae.duration;
                    var aeFadeIn = Math.min(1, ae.age / 20), aeFadeOut = ae.age > ae.duration - 30 ? Math.max(0, (ae.duration - ae.age) / 30) : 1;
                    var aeAlpha = aeFadeIn * aeFadeOut;

                    if (ae.type === 'eclipse') {
                        var eclStr = Math.sin(aeP * Math.PI) * 0.7;
                        ctx.save(); ctx.fillStyle = 'rgba(0,0,10,' + (eclStr * aeAlpha) + ')'; ctx.fillRect(0, 0, W, H);
                        ctx.globalAlpha = eclStr * aeAlpha;
                        for (var si = 0; si < 30; si++) {
                            var sx2 = ((si * 137.5) % W), sy2 = ((si * 97.3 + si * si * 7) % H);
                            ctx.fillStyle = 'rgba(255,255,255,' + (0.5 + Math.sin(tickCount * 0.1 + si * 2) * 0.5) + ')';
                            ctx.fillRect(sx2, sy2, 2, 2);
                        }
                        var eclGrd = ctx.createRadialGradient(W / 2, H / 2, 0, W / 2, H / 2, Math.max(W, H) * 0.4);
                        eclGrd.addColorStop(0, 'rgba(80,0,120,' + (eclStr * 0.3) + ')'); eclGrd.addColorStop(1, 'rgba(0,0,0,0)');
                        ctx.fillStyle = eclGrd; ctx.fillRect(0, 0, W, H);
                        ctx.fillStyle = '#a040ff'; ctx.font = 'bold 22px sans-serif'; ctx.textAlign = 'center'; ctx.globalAlpha = aeAlpha * 0.8;
                        ctx.fillText('\ud83c\udf11 E C L I P S E', W / 2, 40); ctx.restore();
                    }
                    if (ae.type === 'shockwave') {
                        var swR2 = aeP * Math.max(W, H) * 0.8, swA2 = Math.max(0, 1 - aeP);
                        ctx.save();
                        for (var ri = 0; ri < 3; ri++) {
                            var rr2 = Math.max(0, swR2 - ri * 30);
                            ctx.globalAlpha = swA2 * (1 - ri * 0.3) * aeAlpha; ctx.strokeStyle = ri === 0 ? '#fff' : ri === 1 ? '#aaf' : '#66f';
                            ctx.lineWidth = Math.max(1, (10 - ri * 3) * (1 - aeP));
                            ctx.beginPath(); ctx.arc((bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2, rr2, 0, Math.PI * 2); ctx.stroke();
                        }
                        if (ae.age < 15) {
                            ctx.globalAlpha = Math.max(0, 1 - ae.age / 15) * 0.6;
                            var swGrd = ctx.createRadialGradient((bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2, 0, (bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2, 150);
                            swGrd.addColorStop(0, '#fff'); swGrd.addColorStop(1, 'rgba(100,100,255,0)'); ctx.fillStyle = swGrd; ctx.fillRect(0, 0, W, H);
                        }
                        ctx.restore();
                    }
                    if (ae.type === 'gravity_surge') {
                        var gCx = (bounds[0] + bounds[2]) / 2, gCy = (bounds[1] + bounds[3]) / 2;
                        ctx.save(); ctx.globalAlpha = aeAlpha * 0.6;
                        for (var gi = 0; gi < 12; gi++) {
                            var ga2 = gi / 12 * Math.PI * 2 + tickCount * 0.03, gr1 = Math.max(W, H) * 0.5, gr2 = 20 + Math.sin(tickCount * 0.05 + gi) * 10;
                            ctx.strokeStyle = 'rgba(180,0,255,' + (0.3 + Math.sin(tickCount * 0.1 + gi) * 0.2) + ')'; ctx.lineWidth = 2;
                            ctx.beginPath();
                            for (var gs = 0; gs <= 20; gs++) { var gp2 = gs / 20, gra = ga2 + gp2 * 2, grr = gr1 * (1 - gp2) + gr2 * gp2; if (gs === 0) ctx.moveTo(gCx + Math.cos(gra) * grr, gCy + Math.sin(gra) * grr); else ctx.lineTo(gCx + Math.cos(gra) * grr, gCy + Math.sin(gra) * grr); }
                            ctx.stroke();
                        }
                        var gvGrd = ctx.createRadialGradient(gCx, gCy, 0, gCx, gCy, 100);
                        gvGrd.addColorStop(0, 'rgba(150,0,255,0.5)'); gvGrd.addColorStop(0.5, 'rgba(100,0,200,0.2)'); gvGrd.addColorStop(1, 'rgba(50,0,100,0)');
                        ctx.fillStyle = gvGrd; ctx.beginPath(); ctx.arc(gCx, gCy, 100, 0, Math.PI * 2); ctx.fill();
                        ctx.globalAlpha = aeAlpha; ctx.fillStyle = '#c0f'; ctx.font = 'bold 22px sans-serif'; ctx.textAlign = 'center';
                        ctx.fillText('\ud83c\udf00 GRAVITY SURGE', W / 2, 40); ctx.restore();
                    }
                    if (ae.type === 'frost_nova') {
                        ctx.save(); ctx.globalAlpha = aeAlpha * 0.25 * Math.sin(aeP * Math.PI); ctx.fillStyle = 'rgba(100,180,255,1)'; ctx.fillRect(0, 0, W, H);
                        ctx.globalAlpha = aeAlpha * 0.7;
                        for (var fi = 0; fi < 20; fi++) {
                            var fx2 = ((fi * 173.7 + tickCount * 0.3) % (bounds[2] - bounds[0])) + bounds[0], fy2 = ((fi * 211.3 + fi * fi * 13) % (bounds[3] - bounds[1])) + bounds[1];
                            ctx.strokeStyle = 'rgba(200,230,255,' + (0.4 + Math.sin(tickCount * 0.08 + fi) * 0.3) + ')'; ctx.lineWidth = 1.5;
                            for (var fj = 0; fj < 6; fj++) { var fa2 = fj / 6 * Math.PI * 2 + fi * 0.5, flen = 8 + Math.sin(tickCount * 0.05 + fi) * 3; ctx.beginPath(); ctx.moveTo(fx2, fy2); ctx.lineTo(fx2 + Math.cos(fa2) * flen, fy2 + Math.sin(fa2) * flen); ctx.stroke(); }
                        }
                        ctx.strokeStyle = 'rgba(150,220,255,' + (aeAlpha * 0.6) + ')'; ctx.lineWidth = 6; ctx.setLineDash([8, 4]);
                        ctx.strokeRect(bounds[0], bounds[1], bounds[2] - bounds[0], bounds[3] - bounds[1]); ctx.setLineDash([]);
                        ctx.globalAlpha = aeAlpha; ctx.fillStyle = '#4af'; ctx.font = 'bold 22px sans-serif'; ctx.textAlign = 'center';
                        ctx.fillText('\u2744\ufe0f FROST NOVA', W / 2, 40); ctx.restore();
                    }
                    if (ae.type === 'inferno') {
                        ctx.save(); var infP = Math.sin(aeP * Math.PI);
                        ctx.globalAlpha = aeAlpha * infP * 0.35;
                        var infGrd = ctx.createLinearGradient(0, bounds[3], 0, bounds[1]);
                        infGrd.addColorStop(0, 'rgba(255,100,0,1)'); infGrd.addColorStop(0.4, 'rgba(255,50,0,0.5)'); infGrd.addColorStop(1, 'rgba(200,0,0,0)');
                        ctx.fillStyle = infGrd; ctx.fillRect(bounds[0], bounds[1], bounds[2] - bounds[0], bounds[3] - bounds[1]);
                        ctx.globalAlpha = aeAlpha * 0.8;
                        for (var ii = 0; ii < 40; ii++) {
                            var ix2 = ((ii * 127.3) % (bounds[2] - bounds[0])) + bounds[0], iy2 = bounds[3] - ((tickCount * 1.5 + ii * 37) % (bounds[3] - bounds[1]));
                            var iSize2 = 3 + Math.sin(tickCount * 0.1 + ii) * 2;
                            ctx.globalAlpha = aeAlpha * Math.max(0, 1 - (bounds[3] - iy2) / (bounds[3] - bounds[1])) * 0.7;
                            ctx.fillStyle = ['#f80', '#fa0', '#f00', '#ff0'][ii % 4]; ctx.beginPath(); ctx.arc(ix2, iy2, iSize2, 0, Math.PI * 2); ctx.fill();
                        }
                        ctx.globalAlpha = aeAlpha * 0.15; ctx.strokeStyle = '#f80'; ctx.lineWidth = 1;
                        for (var hi2 = 0; hi2 < 5; hi2++) {
                            var hy2 = bounds[1] + (bounds[3] - bounds[1]) * (0.3 + hi2 * 0.15); ctx.beginPath();
                            for (var hx2 = bounds[0]; hx2 < bounds[2]; hx2 += 5) { var hwy2 = hy2 + Math.sin(hx2 * 0.02 + tickCount * 0.08 + hi2) * 8; if (hx2 === bounds[0]) ctx.moveTo(hx2, hwy2); else ctx.lineTo(hx2, hwy2); } ctx.stroke();
                        }
                        ctx.globalAlpha = aeAlpha; ctx.fillStyle = '#f80'; ctx.font = 'bold 22px sans-serif'; ctx.textAlign = 'center';
                        ctx.fillText('\ud83d\udd25 I N F E R N O', W / 2, 40); ctx.restore();
                    }
                    if (ae.type === 'meteor_shower') {
                        ctx.save(); ctx.globalAlpha = aeAlpha * 0.2;
                        var msGrd = ctx.createLinearGradient(0, 0, 0, H * 0.5);
                        msGrd.addColorStop(0, 'rgba(255,60,0,1)'); msGrd.addColorStop(1, 'rgba(0,0,0,0)');
                        ctx.fillStyle = msGrd; ctx.fillRect(0, 0, W, H);
                        ctx.globalAlpha = aeAlpha; ctx.fillStyle = '#fa0'; ctx.font = 'bold 22px sans-serif'; ctx.textAlign = 'center';
                        ctx.fillText('\u2604\ufe0f METEOR SHOWER', W / 2, 40); ctx.restore();
                    }
                }
                // Render meteors
                for (var mi2 = 0; mi2 < meteors.length; mi2++) {
                    var mt2 = meteors[mi2];
                    if (mt2.hit) {
                        var crAge = mt2.age - mt2.maxAge, crAlpha = Math.max(0, 1 - crAge / 20);
                        ctx.save(); ctx.globalAlpha = crAlpha * 0.5;
                        var crGrd = ctx.createRadialGradient(mt2.tx, mt2.ty, 0, mt2.tx, mt2.ty, 50);
                        crGrd.addColorStop(0, 'rgba(255,150,0,0.8)'); crGrd.addColorStop(0.5, 'rgba(255,80,0,0.3)'); crGrd.addColorStop(1, 'rgba(0,0,0,0)');
                        ctx.fillStyle = crGrd; ctx.beginPath(); ctx.arc(mt2.tx, mt2.ty, 50, 0, Math.PI * 2); ctx.fill(); ctx.restore();
                    } else {
                        var mtP2 = mt2.age / mt2.maxAge;
                        ctx.save(); ctx.globalAlpha = 0.9;
                        ctx.strokeStyle = '#fa0'; ctx.lineWidth = 4; ctx.shadowColor = '#f80'; ctx.shadowBlur = 15;
                        ctx.beginPath(); ctx.moveTo(mt2.x - (mt2.tx - mt2.x) * 0.5, mt2.y - (mt2.ty - mt2.y) * 0.5); ctx.lineTo(mt2.x, mt2.y); ctx.stroke();
                        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(mt2.x, mt2.y, 5 + mtP2 * 3, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
                        ctx.globalAlpha = 0.2 + mtP2 * 0.3; ctx.strokeStyle = '#f00'; ctx.lineWidth = 2; ctx.setLineDash([4, 4]);
                        ctx.beginPath(); ctx.arc(mt2.tx, mt2.ty, 40 - mtP2 * 20, 0, Math.PI * 2); ctx.stroke(); ctx.setLineDash([]); ctx.restore();
                    }
                }

                for (var id in monsters) {
                    var m = monsters[id]; if (!m || !m.path || !m.path.length) continue;
                    var sc = m.size / 40, pcx = 0, pcy = 0;
                    for (var i = 0; i < m.path.length; i++) { pcx += m.path[i][0] * 12; pcy += m.path[i][1] * 12 } pcx /= m.path.length; pcy /= m.path.length;

                    if (m.trail && m.trail.length > 1) { for (var ti = 0; ti < m.trail.length - 1; ti++) { ctx.globalAlpha = (ti / m.trail.length) * 0.4; ctx.fillStyle = m.color; ctx.beginPath(); ctx.arc(m.trail[ti].x, m.trail[ti].y, m.size * 0.3 * (ti / m.trail.length), 0, Math.PI * 2); ctx.fill() } ctx.globalAlpha = 1 }
                    if (m.effects && (m.effects.speed || m.effects.shield || m.effects.damage || m.effects.ghost)) {
                        var maxR = 0; for (var ei = 0; ei < m.path.length; ei++) { var edx = (m.path[ei][0] * 12 - pcx) * sc, edy = (m.path[ei][1] * 12 - pcy) * sc; var er = Math.hypot(edx, edy); if (er > maxR) maxR = er }
                        var glowR = maxR + 8;
                        ctx.save(); ctx.globalAlpha = 0.35; ctx.fillStyle = m.effects.shield ? '#08f' : m.effects.speed ? '#ff0' : m.effects.damage ? '#f00' : '#aaa'; ctx.beginPath(); ctx.arc(m.x, m.y, glowR, 0, Math.PI * 2); ctx.fill(); ctx.restore();
                        var eLbl = m.effects.shield ? '\ud83d\udee1 SHIELD' : m.effects.speed ? '\u26a1 FAST' : m.effects.damage ? '\ud83d\udca5 2xDMG' : '\ud83d\udc7b PHASE';
                        var eClr = m.effects.shield ? '#4af' : m.effects.speed ? '#ff0' : m.effects.damage ? '#f66' : '#ccc';
                        ctx.save(); ctx.globalAlpha = 0.9; ctx.fillStyle = eClr; ctx.font = 'bold 8px sans-serif'; ctx.textAlign = 'center'; ctx.fillText(eLbl, m.x, m.y + maxR + 14); ctx.restore();
                    }

                    ctx.save(); ctx.translate(m.x, m.y); ctx.scale(sc, sc);
                    ctx.fillStyle = m.effects && m.effects.ghost ? 'rgba(255,255,255,0.3)' : m.color;
                    ctx.beginPath(); ctx.moveTo(m.path[0][0] * 12 - pcx, m.path[0][1] * 12 - pcy);
                    for (var i = 1; i < m.path.length; i++) ctx.lineTo(m.path[i][0] * 12 - pcx, m.path[i][1] * 12 - pcy);
                    ctx.closePath(); ctx.fill(); ctx.restore();

                    ctx.fillStyle = '#fff'; ctx.font = 'bold ' + Math.max(16, Math.round(22 * sc)) + 'px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(Math.ceil(m.hp), m.x, m.y);
                    if (m.name) { ctx.font = 'bold ' + Math.max(13, Math.round(16 * sc)) + 'px sans-serif'; ctx.fillText(m.name, m.x, m.y - m.size * 1.5 - 10) }
                }

                for (var i = 0; i < particles.length; i++) { var p = particles[i]; ctx.globalAlpha = Math.max(0, 1 - p.age / 30); ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI * 2); ctx.fill() } ctx.globalAlpha = 1;
                for (var i = 0; i < blastFx.length; i++) { var b = blastFx[i], a = Math.max(0, 1 - b.age / 20); ctx.strokeStyle = 'rgba(255,255,255,' + a + ')'; ctx.lineWidth = Math.max(1, 4 - b.age * 0.15); ctx.beginPath(); ctx.arc(b.x, b.y, b.age * 4, 0, Math.PI * 2); ctx.stroke(); ctx.strokeStyle = 'rgba(255,255,255,' + (a * 0.5) + ')'; ctx.beginPath(); ctx.arc(b.x, b.y, b.age * 4 * 0.6, 0, Math.PI * 2); ctx.stroke() }
                for (var i = 0; i < floatTexts.length; i++) { var f = floatTexts[i]; ctx.globalAlpha = Math.max(0, 1 - f.age / 40); ctx.fillStyle = f.color; ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center'; ctx.fillText(f.text, f.x, f.y - f.age * 0.8); ctx.globalAlpha = 1 }
                ctx.restore(); // end screen shake transform

                // Update button text
                var m = monsters[0];
                var bBtn = document.getElementById('blastBtn'), aBtn = document.getElementById('abilityBtn');
                if (!m) {
                    if (bBtn) bBtn.textContent = 'Dead';
                    if (aBtn) aBtn.textContent = 'Dead';
                } else {
                    if (bBtn) bBtn.textContent = 'Blast' + ((blastCooldown > 0) ? ' (' + Math.ceil(blastCooldown / 60) + ')' : '');
                    if (aBtn) aBtn.textContent = m.ability === 'none' ? 'No Ability' : (m.ability.toUpperCase() + ((m.abilityCooldown > 0) ? ' (' + Math.ceil(m.abilityCooldown / 60) + ')' : ''));
                }
            }

            function updateStats() {
                document.getElementById('roundNum').textContent = roundNumber;
                document.getElementById('winCount').textContent = wins;
                document.getElementById('lossCount').textContent = losses;
            }

            function startNewRound() {
                if (!simRunning || !savedPlayerPath) return;
                roundNumber++;
                updateStats();

                logEl.innerHTML = '';
                monsters = {}; packs = []; powerups = []; hazards = []; particles = []; blastFx = []; floatTexts = []; activeBlasts = [];
                bounds = [0, 0, W, H]; tickCount = 0; suddenDeath = false; blastCooldown = 0;
                lightningWarning = null; lightningStrike = null;
                arenaEvent = null; arenaEventWarning = null; meteors = []; screenShake = { x: 0, y: 0, intensity: 0, decay: 0.9 };

                var playerName = savedPlayerName || 'You';
                monsters[0] = initMonster(0, savedPlayerPath.slice(), myColor, playerName, false);
                for (var i = 0; i < numBots; i++) monsters[i + 1] = initMonster(i + 1, genBot(150, 150), '#e74c3c', 'Bot' + (i + 1), true);

                spawnPack(); spawnPack();
                addLog('--- Round ' + roundNumber + ' ---');

                if (gameLoop) clearInterval(gameLoop);
                gameLoop = setInterval(update, 16);
            }

            var isScotty = false;
            var menu = document.getElementById('menu'), ui = document.getElementById('ui'), arena = document.getElementById('arena'), c = document.getElementById('c'), ac = document.getElementById('ac');
            var start1 = document.getElementById('start1'), start3 = document.getElementById('start3'), start5 = document.getElementById('start5'), clearBtn = document.getElementById('clear'), doneBtn = document.getElementById('done');
            var blastBtn = document.getElementById('blastBtn'), abilityBtn = document.getElementById('abilityBtn'), loadScottyBtn = document.getElementById('loadScotty');
            var stopBtn = document.getElementById('stopBtn');

            function startGame(nb) { numBots = nb; menu.style.display = 'none'; ui.style.display = 'block'; c.style.display = 'block'; path = []; var ctx = c.getContext('2d'); ctx.fillStyle = '#1a1a24'; ctx.fillRect(0, 0, 300, 300) }
            if (start1) start1.onclick = function () { startGame(1) };
            if (start3) start3.onclick = function () { startGame(3) };
            if (start5) start5.onclick = function () { startGame(5) };

            function getXY(e) { var r = c.getBoundingClientRect(), sx = 300 / r.width, sy = 300 / r.height, px = (e.touches ? e.touches[0].clientX : e.clientX) - r.left, py = (e.touches ? e.touches[0].clientY : e.clientY) - r.top; return { x: clamp(px * sx, 5, 295), y: clamp(py * sy, 5, 295) } }
            function smooth(p) { for (var k = 0; k < 2; k++) { var n = []; for (var i = 0; i < p.length; i++) { var a = p[i - 1] || p[0], b = p[i], cc = p[i + 1] || p[p.length - 1]; n.push({ x: (a.x + b.x * 2 + cc.x) / 4, y: (a.y + b.y * 2 + cc.y) / 4 }) } p = n } return p }
            function onDown(e) { isScotty = false; var p = getXY(e); path = [p] }
            function onMove(e) { if (!path.length) return; var p = getXY(e); path.push(p); var d = smooth(path.slice()), ctx = c.getContext('2d'); ctx.fillStyle = '#1a1a24'; ctx.fillRect(0, 0, 300, 300); ctx.strokeStyle = myColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(d[0].x, d[0].y); for (var i = 1; i < d.length; i++)ctx.lineTo(d[i].x, d[i].y); ctx.stroke() }
            function onUp() { if (path.length < 10) return; path = smooth(path); var g = Math.hypot(path[0].x - path[path.length - 1].x, path[0].y - path[path.length - 1].y); if (g > 5) { var s = Math.ceil(g / 10), ex = path[path.length - 1].x, ey = path[path.length - 1].y; for (var i = 1; i <= s; i++) { var t = i / s; path.push({ x: ex * (1 - t) + path[0].x * t, y: ey * (1 - t) + path[0].y * t }) } } path.push({ x: path[0].x, y: path[0].y }); document.getElementById('drawStatus').textContent = 'Shape ready!'; document.getElementById('drawStatus').style.color = '#2ecc71'; var ctx = c.getContext('2d'); ctx.fillStyle = '#1a1a24'; ctx.fillRect(0, 0, 300, 300); ctx.fillStyle = myColor; ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y); for (var i = 1; i < path.length; i++)ctx.lineTo(path[i].x, path[i].y); ctx.fill() }

            c.addEventListener('touchstart', function (e) { e.preventDefault(); onDown(e) }); c.addEventListener('touchmove', function (e) { e.preventDefault(); onMove(e) }); c.addEventListener('touchend', function (e) { e.preventDefault(); onUp() });
            c.addEventListener('mousedown', onDown); c.addEventListener('mousemove', function (e) { if (e.buttons) onMove(e) }); c.addEventListener('mouseup', onUp);
            clearBtn.onclick = function () { path = []; var ctx = c.getContext('2d'); ctx.fillStyle = '#1a1a24'; ctx.fillRect(0, 0, 300, 300); document.getElementById('drawStatus').textContent = 'Draw your monster'; document.getElementById('drawStatus').style.color = '#888' };
            if (loadScottyBtn) loadScottyBtn.onclick = function () {
                path = [
                    { x: 270, y: 115 },
                    { x: 255, y: 105 },
                    { x: 248, y: 92 },
                    { x: 240, y: 58 },
                    { x: 232, y: 46 },
                    { x: 225, y: 65 },
                    { x: 218, y: 72 },
                    { x: 212, y: 65 },
                    { x: 205, y: 46 },
                    { x: 198, y: 70 },
                    { x: 192, y: 100 },
                    { x: 186, y: 118 },
                    { x: 110, y: 125 },
                    { x: 78, y: 118 },
                    { x: 58, y: 68 },
                    { x: 64, y: 105 },
                    { x: 68, y: 148 },
                    { x: 76, y: 188 },
                    { x: 80, y: 228 },
                    { x: 102, y: 228 },
                    { x: 108, y: 198 },
                    { x: 198, y: 195 },
                    { x: 215, y: 205 },
                    { x: 220, y: 228 },
                    { x: 240, y: 228 },
                    { x: 242, y: 192 },
                    { x: 250, y: 165 },
                    { x: 262, y: 152 },
                    { x: 272, y: 135 },
                ];
                path.push({ x: path[0].x, y: path[0].y });
                isScotty = true;
                var ctx = c.getContext('2d'); ctx.fillStyle = '#1a1a24'; ctx.fillRect(0, 0, 300, 300);
                ctx.fillStyle = myColor; ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y); for (var i = 1; i < path.length; i++)ctx.lineTo(path[i].x, path[i].y); ctx.fill();
                document.getElementById('drawStatus').textContent = 'Scotty Loaded!'; document.getElementById('drawStatus').style.color = '#c0392b';
            };

            function genBot(cx, cy) {
                var p = [], r = rand(30, 70), pts = Math.floor(rand(5, 12));
                for (var i = 0; i < pts; i++) { var a = i / pts * 6.28, rr = r + rand(-15, 25); p.push([Math.round((cx + Math.cos(a) * rr) / 12), Math.round((cy + Math.sin(a) * rr) / 12)]) }
                return p
            }

            doneBtn.onclick = function () {
                if (path.length < 10) return;
                var mx = 1e9, my = 1e9, Mx = 0, My = 0; for (var i = 0; i < path.length; i++) { mx = Math.min(mx, path[i].x); my = Math.min(my, path[i].y); Mx = Math.max(Mx, path[i].x); My = Math.max(My, path[i].y) }
                var sw = Mx - mx || 1, sh = My - my || 1, sc = Math.min(220 / sw, 220 / sh), ox = 150 - (mx + Mx) / 2 * sc, oy = 150 - (my + My) / 2 * sc;
                var p = [], ns = Math.min(path.length, 30); for (var i = 0; i < ns; i++) { var j = Math.floor(i * (path.length - 1) / (ns - 1)); p.push([Math.round((path[j].x * sc + ox) / 12), Math.round((path[j].y * sc + oy) / 12)]) }

                // Save the player path and name for re-use across rounds
                savedPlayerPath = p;
                var nameVal = document.getElementById('nameInput').value.trim();
                savedPlayerName = nameVal || 'You';
                simRunning = true;
                resizeArena();
                roundNumber = 0;
                wins = 0;
                losses = 0;

                ui.style.display = 'none'; arena.style.display = 'flex';
                startNewRound();
            };

            // Stop simulation
            stopBtn.onclick = function () {
                simRunning = false;
                if (gameLoop) { clearInterval(gameLoop); gameLoop = null; }
                arena.style.display = 'none';
                menu.style.display = 'block';
                path = [];
                savedPlayerPath = null;
                savedPlayerName = null;
            };

            var blastCooldown = 0, keys = {};
            document.addEventListener('keydown', function (e) { keys[e.key] = true }); document.addEventListener('keyup', function (e) { keys[e.key] = false });
            if (blastBtn) blastBtn.onclick = function () { if (!monsters[0] || blastCooldown > 0) return; blast(0); blastCooldown = 300 };
            if (abilityBtn) abilityBtn.onclick = function () { if (!monsters[0]) return; useAbility(0) };

            window.addEventListener('resize', function () { if (simRunning) { resizeArena(); bounds = [0, 0, W, H]; } });

            setInterval(function () {
                if (monsters[0] && monsters[0].hp > 0 && !gameLoop) return;
                if (blastCooldown > 0) blastCooldown--;
                if (monsters[0] && monsters[0].hp > 0) {
                    var m = monsters[0], sp = m.speed;
                    if (keys.ArrowUp || keys.w || keys.W) m.vy -= sp * 0.15; if (keys.ArrowDown || keys.s || keys.S) m.vy += sp * 0.15;
                    if (keys.ArrowLeft || keys.a || keys.A) m.vx -= sp * 0.15; if (keys.ArrowRight || keys.d || keys.D) m.vx += sp * 0.15;
                    if (keys[' '] && blastCooldown <= 0) blastBtn.click();
                    if (keys.Shift || keys.e || keys.E) abilityBtn.click();
                }
            }, 16);
        })();
    </script>
</body>

</html>
